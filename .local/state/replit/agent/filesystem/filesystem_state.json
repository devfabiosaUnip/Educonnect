{"file_contents":{"src/professor/professor.c":{"content":"#include \"professor/professor.h\"\n#include \"models.h\"\n#include \"storage/storage.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"protocol.h\" // Para MAX_DATA_LEN e outras macros\n\n// Implementação das funções de gerenciamento de Professores\n\n// Funções de Gerenciamento de Matérias/Turmas\nvoid list_professor_assigned_classes(int professor_id, char* data_buffer, int buffer_size) {\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(data_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return;\n    }\n\n    if (prof->num_assigned_classes == 0) {\n        snprintf(data_buffer, buffer_size, \"Nenhuma turma atribuída ao professor %s.\", prof->name);\n        return;\n    }\n\n    char temp_buffer[200];\n    data_buffer[0] = '\\0';\n\n    snprintf(temp_buffer, sizeof(temp_buffer), \"Turmas atribuídas a %s (ID: %d):\\n\", prof->name, professor_id);\n    if (strlen(data_buffer) + strlen(temp_buffer) < (size_t)buffer_size) {\n        strcat(data_buffer, temp_buffer);\n    } else {\n        snprintf(data_buffer, buffer_size, \"... (lista truncada)\");\n        return;\n    }\n\n    for (int i = 0; i < prof->num_assigned_classes; i++) {\n        int class_id = prof->assigned_classes[i];\n        char class_name[MAX_STR_LEN] = \"Desconhecida\";\n        for (int j = 0; j < global_data.num_classes; j++) {\n            if (global_data.classes[j].id == class_id) {\n                strncpy(class_name, global_data.classes[j].name, MAX_STR_LEN - 1);\n                class_name[MAX_STR_LEN - 1] = '\\0';\n                break;\n            }\n        }\n        snprintf(temp_buffer, sizeof(temp_buffer), \"  - ID: %d, Nome: %s\\n\", class_id, class_name);\n        if (strlen(data_buffer) + strlen(temp_buffer) < (size_t)buffer_size) {\n            strcat(data_buffer, temp_buffer);\n        } else {\n            strcat(data_buffer, \"... (lista truncada)\");\n            break;\n        }\n    }\n}\n\nvoid list_professor_assigned_subjects(int professor_id, char* data_buffer, int buffer_size) {\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(data_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return;\n    }\n\n    if (prof->num_assigned_subjects == 0) {\n        snprintf(data_buffer, buffer_size, \"Nenhuma matéria atribuída ao professor %s.\", prof->name);\n        return;\n    }\n\n    char temp_buffer[200];\n    data_buffer[0] = '\\0';\n\n    snprintf(temp_buffer, sizeof(temp_buffer), \"Matérias atribuídas a %s (ID: %d):\\n\", prof->name, professor_id);\n    if (strlen(data_buffer) + strlen(temp_buffer) < (size_t)buffer_size) {\n        strcat(data_buffer, temp_buffer);\n    } else {\n        snprintf(data_buffer, buffer_size, \"... (lista truncada)\");\n        return;\n    }\n\n    for (int i = 0; i < prof->num_assigned_subjects; i++) {\n        int subject_id = prof->assigned_subjects[i];\n        char subject_name[MAX_STR_LEN] = \"Desconhecida\";\n        for (int j = 0; j < global_data.num_subjects; j++) {\n            if (global_data.subjects[j].id == subject_id) {\n                strncpy(subject_name, global_data.subjects[j].name, MAX_STR_LEN - 1);\n                subject_name[MAX_STR_LEN - 1] = '\\0';\n                break;\n            }\n        }\n        snprintf(temp_buffer, sizeof(temp_buffer), \"  - ID: %d, Nome: %s\\n\", subject_id, subject_name);\n        if (strlen(data_buffer) + strlen(temp_buffer) < (size_t)buffer_size) {\n            strcat(data_buffer, temp_buffer);\n        } else {\n            strcat(data_buffer, \"... (lista truncada)\");\n            break;\n        }\n    }\n}\n\n// Funções de Notas e Faltas\nint post_grade(int professor_id, int student_id, int subject_id, float grade_value, const char* description, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Verificar se o aluno existe\n    Student* student = NULL;\n    for (int i = 0; i < global_data.num_students; i++) {\n        if (global_data.students[i].id == student_id) {\n            student = &global_data.students[i];\n            break;\n        }\n    }\n    if (!student) {\n        snprintf(message_buffer, buffer_size, \"Erro: Aluno com ID %d não encontrado.\", student_id);\n        return -1;\n    }\n\n    // Verificar se a matéria existe (e se o professor está associado a ela)\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n    if (!subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Matéria com ID %d não encontrada.\", subject_id);\n        return -1;\n    }\n\n    // Verificar limite de notas para o aluno\n    if (global_data.num_grades >= MAX_GRADES_PER_STUDENT * MAX_STUDENTS) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite total de notas atingido no sistema.\");\n        return -1;\n    }\n\n    // Adicionar a nota\n    Grade new_grade;\n    new_grade.student_id = student_id;\n    new_grade.subject_id = subject_id;\n    new_grade.grade_value = grade_value;\n    strncpy(new_grade.description, description, MAX_STR_LEN - 1);\n    new_grade.description[MAX_STR_LEN - 1] = '\\0';\n\n    global_data.grades[global_data.num_grades++] = new_grade;\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Nota %.2f lançada para o aluno %s na matéria %s com sucesso!\", grade_value, student->name, subject->name);\n    return 0;\n}\n\nint register_absence(int professor_id, int student_id, int subject_id, const char* date, const char* justification, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Verificar se o aluno existe\n    Student* student = NULL;\n    for (int i = 0; i < global_data.num_students; i++) {\n        if (global_data.students[i].id == student_id) {\n            student = &global_data.students[i];\n            break;\n        }\n    }\n    if (!student) {\n        snprintf(message_buffer, buffer_size, \"Erro: Aluno com ID %d não encontrado.\", student_id);\n        return -1;\n    }\n\n    // Verificar se a matéria existe (e se o professor está associado a ela)\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n    if (!subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Matéria com ID %d não encontrada.\", subject_id);\n        return -1;\n    }\n\n    // Verificar limite de faltas para o aluno\n    if (global_data.num_absences >= MAX_ABSENCES_PER_STUDENT * MAX_STUDENTS) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite total de faltas atingido no sistema.\");\n        return -1;\n    }\n\n    // Adicionar a falta\n    Absence new_absence;\n    new_absence.student_id = student_id;\n    new_absence.subject_id = subject_id;\n    strncpy(new_absence.date, date, MAX_STR_LEN - 1);\n    new_absence.date[MAX_STR_LEN - 1] = '\\0';\n    strncpy(new_absence.justification, justification, MAX_STR_LEN - 1);\n    new_absence.justification[MAX_STR_LEN - 1] = '\\0';\n\n    global_data.absences[global_data.num_absences++] = new_absence;\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Falta registrada para o aluno %s na matéria %s em %s com sucesso!\", student->name, subject->name, date);\n    return 0;\n}\n\nvoid view_student_grades_absences(int professor_id, int student_id, char* data_buffer, int buffer_size) {\n    data_buffer[0] = '\\0'; // Garante que o buffer de saída comece vazio\n\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(data_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return;\n    }\n\n    // Verificar se o aluno existe\n    Student* student = NULL;\n    for (int i = 0; i < global_data.num_students; i++) {\n        if (global_data.students[i].id == student_id) {\n            student = &global_data.students[i];\n            break;\n        }\n    }\n    if (!student) {\n        snprintf(data_buffer, buffer_size, \"Erro: Aluno com ID %d não encontrado.\", student_id);\n        return;\n    }\n\n    char temp_buffer[MAX_DATA_LEN]; // Usar um buffer auxiliar grande o suficiente\n    int offset = 0;\n\n    offset += snprintf(data_buffer + offset, buffer_size - offset, \"Notas e Faltas de %s (ID: %d):\\n\", student->name, student_id);\n\n    // Listar Notas\n    offset += snprintf(data_buffer + offset, buffer_size - offset, \"--- Notas ---\\n\");\n    int grades_found = 0;\n    for (int i = 0; i < global_data.num_grades; i++) {\n        if (global_data.grades[i].student_id == student_id) {\n            Subject* subject = NULL;\n            for (int j = 0; j < global_data.num_subjects; j++) {\n                if (global_data.subjects[j].id == global_data.grades[i].subject_id) {\n                    subject = &global_data.subjects[j];\n                    break;\n                }\n            }\n            snprintf(temp_buffer, sizeof(temp_buffer), \"  - Matéria: %s (ID: %d), Nota: %.2f, Descrição: %s\\n\",\n                     subject ? subject->name : \"Desconhecida\",\n                     global_data.grades[i].subject_id,\n                     global_data.grades[i].grade_value,\n                     global_data.grades[i].description);\n            if ((size_t)offset + strlen(temp_buffer) < (size_t)buffer_size) {\n                strcat(data_buffer + offset, temp_buffer);\n                offset += strlen(temp_buffer);\n            } else { break; }\n            grades_found = 1;\n        }\n    }\n    if (!grades_found) {\n        offset += snprintf(data_buffer + offset, buffer_size - offset, \"  Nenhuma nota registrada.\\n\");\n    }\n\n    // Listar Faltas\n    offset += snprintf(data_buffer + offset, buffer_size - offset, \"--- Faltas ---\\n\");\n    int absences_found = 0;\n    for (int i = 0; i < global_data.num_absences; i++) {\n        if (global_data.absences[i].student_id == student_id) {\n            Subject* subject = NULL;\n            for (int j = 0; j < global_data.num_subjects; j++) {\n                if (global_data.subjects[j].id == global_data.absences[i].subject_id) {\n                    subject = &global_data.subjects[j];\n                    break;\n                }\n            }\n            snprintf(temp_buffer, sizeof(temp_buffer), \"  - Matéria: %s (ID: %d), Data: %s, Justificativa: %s\\n\",\n                     subject ? subject->name : \"Desconhecida\",\n                     global_data.absences[i].subject_id,\n                     global_data.absences[i].date,\n                     global_data.absences[i].justification[0] != '\\0' ? global_data.absences[i].justification : \"Nenhuma\");\n            if ((size_t)offset + strlen(temp_buffer) < (size_t)buffer_size) {\n                strcat(data_buffer + offset, temp_buffer);\n                offset += strlen(temp_buffer);\n            } else {\n                strcat(data_buffer, \"... (lista truncada)\");\n                break;\n            }\n        }\n    }\n    if (!absences_found) {\n        offset += snprintf(data_buffer + offset, buffer_size - offset, \"  Nenhuma falta registrada.\\n\");\n    }\n}\n\n// Funções de Módulos e Aulas\nint create_subject_module(int professor_id, int subject_id, const char* module_name, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Verificar se a matéria existe\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n    if (!subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Matéria com ID %d não encontrada.\", subject_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria\n    int is_prof_assigned_to_subject = 0;\n    for (int i = 0; i < prof->num_assigned_subjects; i++) {\n        if (prof->assigned_subjects[i] == subject_id) {\n            is_prof_assigned_to_subject = 1;\n            break;\n        }\n    }\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria com ID %d.\", professor_id, subject_id);\n        return -1;\n    }\n\n    // Verificar limite de módulos para a matéria\n    if (subject->num_modules >= MAX_MODULES_PER_SUBJECT) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite de módulos atingido para a matéria %s.\", subject->name);\n        return -1;\n    }\n\n    // Verificar limite total de módulos\n    if (global_data.num_modules >= (int)(sizeof(global_data.modules) / sizeof(Module))) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite total de módulos atingido no sistema.\");\n        return -1;\n    }\n\n    // Criar novo módulo\n    Module new_module;\n    new_module.id = (global_data.num_modules > 0) ? global_data.modules[global_data.num_modules - 1].id + 1 : 1; // ID incremental\n    strncpy(new_module.name, module_name, MAX_STR_LEN - 1);\n    new_module.name[MAX_STR_LEN - 1] = '\\0';\n    new_module.subject_id = subject_id;\n    new_module.num_lessons = 0;\n    new_module.num_quizzes = 0;\n\n    global_data.modules[global_data.num_modules] = new_module;\n    subject->module_ids[subject->num_modules++] = new_module.id;\n    global_data.num_modules++;\n\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Módulo \\\"%s\\\" criado com sucesso na matéria %s! (ID: %d)\", new_module.name, subject->name, new_module.id);\n    return 0;\n}\n\nvoid list_subject_modules(int professor_id, int subject_id, char* data_buffer, int buffer_size) {\n    data_buffer[0] = '\\0'; // Garante que o buffer de saída comece vazio\n\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(data_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return;\n    }\n\n    // Verificar se a matéria existe\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n    if (!subject) {\n        snprintf(data_buffer, buffer_size, \"Erro: Matéria com ID %d não encontrada.\", subject_id);\n        return;\n    }\n\n    // Verificar se o professor está associado à matéria\n    int is_prof_assigned_to_subject = 0;\n    for (int i = 0; i < prof->num_assigned_subjects; i++) {\n        if (prof->assigned_subjects[i] == subject_id) {\n            is_prof_assigned_to_subject = 1;\n            break;\n        }\n    }\n    if (!is_prof_assigned_to_subject) {\n        snprintf(data_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria com ID %d.\", professor_id, subject_id);\n        return;\n    }\n\n    if (subject->num_modules == 0) {\n        snprintf(data_buffer, buffer_size, \"Nenhum módulo cadastrado para a matéria %s (ID: %d).\", subject->name, subject_id);\n        return;\n    }\n\n    char temp_buffer[200];\n    int offset = 0;\n\n    offset += snprintf(data_buffer + offset, buffer_size - offset, \"Módulos da matéria %s (ID: %d):\\n\", subject->name, subject_id);\n\n    for (int i = 0; i < subject->num_modules; i++) {\n        int module_id = subject->module_ids[i];\n        Module* module = NULL;\n        for (int j = 0; j < global_data.num_modules; j++) {\n            if (global_data.modules[j].id == module_id) {\n                module = &global_data.modules[j];\n                break;\n            }\n        }\n\n        if (module) {\n            snprintf(temp_buffer, sizeof(temp_buffer), \"  - ID: %d, Nome: %s, Aulas: %d, Questionários: %d\\n\",\n                     module->id, module->name, module->num_lessons, module->num_quizzes);\n            if ((size_t)offset + strlen(temp_buffer) < (size_t)buffer_size) {\n                strcat(data_buffer + offset, temp_buffer);\n                offset += strlen(temp_buffer);\n            } else {\n                strcat(data_buffer, \"... (lista truncada)\");\n                break;\n            }\n        }\n    }\n}\n\nint edit_module(int professor_id, int module_id, const char* new_name, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Encontrar o módulo\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(message_buffer, buffer_size, \"Erro: Módulo com ID %d não encontrado.\", module_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo com ID %d.\", professor_id, module->subject_id);\n        return -1;\n    }\n\n    strncpy(module->name, new_name, MAX_STR_LEN - 1);\n    module->name[MAX_STR_LEN - 1] = '\\0';\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Módulo com ID %d atualizado para \\\"%s\\\" com sucesso!\", module_id, new_name);\n    return 0;\n}\n\nint remove_module(int professor_id, int module_id, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Encontrar o módulo e sua posição em global_data.modules\n    int module_index_in_global_data = -1;\n    Module* module_to_remove = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == module_id) {\n            module_to_remove = &global_data.modules[i];\n            module_index_in_global_data = i;\n            break;\n        }\n    }\n    if (!module_to_remove) {\n        snprintf(message_buffer, buffer_size, \"Erro: Módulo com ID %d não encontrado.\", module_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module_to_remove->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo com ID %d.\", professor_id, module_to_remove->subject_id);\n        return -1;\n    }\n\n    // Remover o módulo do array de módulos da matéria\n    if (subject) {\n        int found_module_in_subject_index = -1;\n        for (int i = 0; i < subject->num_modules; i++) {\n            if (subject->module_ids[i] == module_id) {\n                found_module_in_subject_index = i;\n                break;\n            }\n        }\n        if (found_module_in_subject_index != -1) {\n            for (int i = found_module_in_subject_index; i < subject->num_modules - 1; i++) {\n                subject->module_ids[i] = subject->module_ids[i+1];\n            }\n            subject->num_modules--;\n        }\n    }\n\n    // Remover o módulo de global_data.modules (e todas as suas aulas e questionários)\n    if (module_to_remove) {\n        // Remover aulas associadas\n        for (int i = 0; i < module_to_remove->num_lessons; i++) {\n            int lesson_id = module_to_remove->lesson_ids[i];\n            // Encontrar e remover a aula de global_data.lessons\n            for (int j = 0; j < global_data.num_lessons; j++) {\n                if (global_data.lessons[j].id == lesson_id) {\n                    for (int k = j; k < global_data.num_lessons - 1; k++) {\n                        global_data.lessons[k] = global_data.lessons[k+1];\n                    }\n                    global_data.num_lessons--;\n                    j--; // Ajustar o índice devido à remoção\n                }\n            }\n        }\n\n        // Remover questionários associados\n        for (int i = 0; i < module_to_remove->num_quizzes; i++) {\n            int quiz_id = module_to_remove->quiz_ids[i];\n            // Encontrar e remover o questionário de global_data.quizzes\n            // (e também suas perguntas associadas)\n            for (int j = 0; j < global_data.num_quizzes; j++) {\n                if (global_data.quizzes[j].id == quiz_id) {\n                    // Remover perguntas do quiz (elas são inline na struct Quiz)\n                    // Não é necessário um loop separado para perguntas aqui\n                    for (int k = j; k < global_data.num_quizzes - 1; k++) {\n                        global_data.quizzes[k] = global_data.quizzes[k+1];\n                    }\n                    global_data.num_quizzes--;\n                    j--; // Ajustar o índice devido à remoção\n                }\n            }\n        }\n\n        // Remover o módulo do array global_data.modules\n        if (module_index_in_global_data != -1) {\n            for (int i = module_index_in_global_data; i < global_data.num_modules - 1; i++) {\n                global_data.modules[i] = global_data.modules[i+1];\n            }\n            global_data.num_modules--;\n        }\n    }\n\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Módulo com ID %d e seus conteúdos removidos com sucesso!\", module_id);\n    return 0;\n}\n\nint add_lesson_to_module(int professor_id, int module_id, const char* lesson_title, const char* youtube_link, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Encontrar o módulo\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(message_buffer, buffer_size, \"Erro: Módulo com ID %d não encontrado.\", module_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo com ID %d.\", professor_id, module->subject_id);\n        return -1;\n    }\n\n    // Verificar limite de aulas para o módulo\n    if (module->num_lessons >= MAX_LESSONS_PER_MODULE) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite de aulas atingido para o módulo \\\"%s\\\".\", module->name);\n        return -1;\n    }\n\n    // Verificar limite total de aulas\n    if (global_data.num_lessons >= (int)(sizeof(global_data.lessons) / sizeof(Lesson))) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite total de aulas atingido no sistema.\");\n        return -1;\n    }\n\n    // Criar nova aula\n    Lesson new_lesson;\n    new_lesson.id = (global_data.num_lessons > 0) ? global_data.lessons[global_data.num_lessons - 1].id + 1 : 1; // ID incremental\n    strncpy(new_lesson.title, lesson_title, MAX_STR_LEN - 1);\n    new_lesson.title[MAX_STR_LEN - 1] = '\\0';\n    strncpy(new_lesson.youtube_link, youtube_link, MAX_STR_LEN - 1);\n    new_lesson.youtube_link[MAX_STR_LEN - 1] = '\\0';\n    new_lesson.module_id = module_id;\n\n    global_data.lessons[global_data.num_lessons] = new_lesson;\n    module->lesson_ids[module->num_lessons++] = new_lesson.id;\n    global_data.num_lessons++;\n\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Aula \\\"%s\\\" adicionada ao módulo \\\"%s\\\" com sucesso! (ID: %d)\", new_lesson.title, module->name, new_lesson.id);\n    return 0;\n}\n\nint edit_lesson(int professor_id, int lesson_id, const char* new_title, const char* new_youtube_link, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Encontrar a aula\n    Lesson* lesson = NULL;\n    for (int i = 0; i < global_data.num_lessons; i++) {\n        if (global_data.lessons[i].id == lesson_id) {\n            lesson = &global_data.lessons[i];\n            break;\n        }\n    }\n    if (!lesson) {\n        snprintf(message_buffer, buffer_size, \"Erro: Aula com ID %d não encontrada.\", lesson_id);\n        return -1;\n    }\n\n    // Encontrar o módulo da aula\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == lesson->module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(message_buffer, buffer_size, \"Erro interno: Módulo da aula com ID %d não encontrado.\", lesson->module_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo da aula\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo da aula com ID %d.\", professor_id, module->subject_id);\n        return -1;\n    }\n\n    strncpy(lesson->title, new_title, MAX_STR_LEN - 1);\n    lesson->title[MAX_STR_LEN - 1] = '\\0';\n    strncpy(lesson->youtube_link, new_youtube_link, MAX_STR_LEN - 1);\n    lesson->youtube_link[MAX_STR_LEN - 1] = '\\0';\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Aula com ID %d atualizada para \\\"%s\\\" com sucesso!\", lesson_id, new_title);\n    return 0;\n}\n\nint remove_lesson(int professor_id, int lesson_id, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Encontrar a aula e sua posição em global_data.lessons\n    int lesson_index_in_global_data = -1;\n    Lesson* lesson_to_remove = NULL;\n    for (int i = 0; i < global_data.num_lessons; i++) {\n        if (global_data.lessons[i].id == lesson_id) {\n            lesson_to_remove = &global_data.lessons[i];\n            lesson_index_in_global_data = i;\n            break;\n        }\n    }\n    if (!lesson_to_remove) {\n        snprintf(message_buffer, buffer_size, \"Erro: Aula com ID %d não encontrada.\", lesson_id);\n        return -1;\n    }\n\n    // Encontrar o módulo da aula\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == lesson_to_remove->module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(message_buffer, buffer_size, \"Erro interno: Módulo da aula com ID %d não encontrado.\", lesson_to_remove->module_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo da aula\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo da aula com ID %d.\", professor_id, module->subject_id);\n        return -1;\n    }\n\n    // Remover a aula do array de aulas do módulo\n    if (module) {\n        int found_lesson_in_module_index = -1;\n        for (int i = 0; i < module->num_lessons; i++) {\n            if (module->lesson_ids[i] == lesson_id) {\n                found_lesson_in_module_index = i;\n                break;\n            }\n        }\n        if (found_lesson_in_module_index != -1) {\n            for (int i = found_lesson_in_module_index; i < module->num_lessons - 1; i++) {\n                module->lesson_ids[i] = module->lesson_ids[i+1];\n            }\n            module->num_lessons--;\n        }\n    }\n\n    // Remover a aula de global_data.lessons\n    if (lesson_index_in_global_data != -1) {\n        for (int i = lesson_index_in_global_data; i < global_data.num_lessons - 1; i++) {\n            global_data.lessons[i] = global_data.lessons[i+1];\n        }\n        global_data.num_lessons--;\n    }\n\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Aula com ID %d removida com sucesso do módulo \\\"%s\\\"!\", lesson_id, module->name);\n    return 0;\n}\n\nvoid list_module_lessons(int professor_id, int module_id, char* data_buffer, int buffer_size) {\n    data_buffer[0] = '\\0'; // Garante que o buffer de saída comece vazio\n\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(data_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return;\n    }\n\n    // Encontrar o módulo\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(data_buffer, buffer_size, \"Erro: Módulo com ID %d não encontrado.\", module_id);\n        return;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(data_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo com ID %d.\", professor_id, module->subject_id);\n        return;\n    }\n\n    if (module->num_lessons == 0) {\n        snprintf(data_buffer, buffer_size, \"Nenhuma aula cadastrada para o módulo \\\"%s\\\" (ID: %d).\", module->name, module_id);\n        return;\n    }\n\n    char temp_buffer[256];\n    int offset = 0;\n\n    offset += snprintf(data_buffer + offset, buffer_size - offset, \"Aulas do módulo \\\"%s\\\" (ID: %d):\\n\", module->name, module_id);\n\n    for (int i = 0; i < module->num_lessons; i++) {\n        int lesson_id = module->lesson_ids[i];\n        Lesson* lesson = NULL;\n        for (int j = 0; j < global_data.num_lessons; j++) {\n            if (global_data.lessons[j].id == lesson_id) {\n                lesson = &global_data.lessons[j];\n                break;\n            }\n        }\n\n        if (lesson) {\n            snprintf(temp_buffer, sizeof(temp_buffer), \"  - ID: %d, Título: %s, Link: %s\\n\",\n                     lesson->id, lesson->title, lesson->youtube_link);\n            if ((size_t)offset + strlen(temp_buffer) < (size_t)buffer_size) {\n                strcat(data_buffer + offset, temp_buffer);\n                offset += strlen(temp_buffer);\n            } else {\n                strcat(data_buffer, \"... (lista truncada)\");\n                break;\n            }\n        }\n    }\n}\n\n// Funções de Questionários\nint create_module_quiz(int professor_id, int module_id, const char* quiz_title, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Encontrar o módulo\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(message_buffer, buffer_size, \"Erro: Módulo com ID %d não encontrado.\", module_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo com ID %d.\", professor_id, module->subject_id);\n        return -1;\n    }\n\n    // Verificar limite de questionários para o módulo\n    if (module->num_quizzes >= MAX_QUIZZES_PER_MODULE) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite de questionários atingido para o módulo \\\"%s\\\".\", module->name);\n        return -1;\n    }\n\n    // Verificar limite total de questionários\n    if (global_data.num_quizzes >= (int)(sizeof(global_data.quizzes) / sizeof(Quiz))) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite total de questionários atingido no sistema.\");\n        return -1;\n    }\n\n    // Criar novo questionário\n    Quiz new_quiz;\n    new_quiz.id = (global_data.num_quizzes > 0) ? global_data.quizzes[global_data.num_quizzes - 1].id + 1 : 1; // ID incremental\n    strncpy(new_quiz.title, quiz_title, MAX_STR_LEN - 1);\n    new_quiz.title[MAX_STR_LEN - 1] = '\\0';\n    new_quiz.module_id = module_id;\n    new_quiz.num_questions = 0;\n\n    global_data.quizzes[global_data.num_quizzes] = new_quiz;\n    module->quiz_ids[module->num_quizzes++] = new_quiz.id;\n    global_data.num_quizzes++;\n\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Questionário \\\"%s\\\" criado com sucesso no módulo \\\"%s\\\"! (ID: %d)\", new_quiz.title, module->name, new_quiz.id);\n    return 0;\n}\n\nint edit_quiz(int professor_id, int quiz_id, const char* new_title, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Encontrar o questionário\n    Quiz* quiz = NULL;\n    for (int i = 0; i < global_data.num_quizzes; i++) {\n        if (global_data.quizzes[i].id == quiz_id) {\n            quiz = &global_data.quizzes[i];\n            break;\n        }\n    }\n    if (!quiz) {\n        snprintf(message_buffer, buffer_size, \"Erro: Questionário com ID %d não encontrado.\", quiz_id);\n        return -1;\n    }\n\n    // Encontrar o módulo do questionário\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == quiz->module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(message_buffer, buffer_size, \"Erro interno: Módulo do questionário com ID %d não encontrado.\", quiz->module_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo do questionário\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo do questionário com ID %d.\", professor_id, module->subject_id);\n        return -1;\n    }\n\n    strncpy(quiz->title, new_title, MAX_STR_LEN - 1);\n    quiz->title[MAX_STR_LEN - 1] = '\\0';\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Questionário com ID %d atualizado para \\\"%s\\\" com sucesso!\", quiz_id, new_title);\n    return 0;\n}\n\nint remove_quiz(int professor_id, int quiz_id, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Encontrar o questionário e sua posição em global_data.quizzes\n    int quiz_index_in_global_data = -1;\n    Quiz* quiz_to_remove = NULL;\n    for (int i = 0; i < global_data.num_quizzes; i++) {\n        if (global_data.quizzes[i].id == quiz_id) {\n            quiz_to_remove = &global_data.quizzes[i];\n            quiz_index_in_global_data = i;\n            break;\n        }\n    }\n    if (!quiz_to_remove) {\n        snprintf(message_buffer, buffer_size, \"Erro: Questionário com ID %d não encontrado.\", quiz_id);\n        return -1;\n    }\n\n    // Encontrar o módulo do questionário\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == quiz_to_remove->module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(message_buffer, buffer_size, \"Erro interno: Módulo do questionário com ID %d não encontrado.\", quiz_to_remove->module_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo do questionário\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo do questionário com ID %d.\", professor_id, module->subject_id);\n        return -1;\n    }\n\n    // Remover o questionário do array de questionários do módulo\n    if (module) {\n        int found_quiz_in_module_index = -1;\n        for (int i = 0; i < module->num_quizzes; i++) {\n            if (module->quiz_ids[i] == quiz_id) {\n                found_quiz_in_module_index = i;\n                break;\n            }\n        }\n        if (found_quiz_in_module_index != -1) {\n            for (int i = found_quiz_in_module_index; i < module->num_quizzes - 1; i++) {\n                module->quiz_ids[i] = module->quiz_ids[i+1];\n            }\n            module->num_quizzes--;\n        }\n    }\n\n    // Remover o questionário de global_data.quizzes\n    if (quiz_index_in_global_data != -1) {\n        for (int i = quiz_index_in_global_data; i < global_data.num_quizzes - 1; i++) {\n            global_data.quizzes[i] = global_data.quizzes[i+1];\n        }\n        global_data.num_quizzes--;\n    }\n\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Questionário com ID %d removido com sucesso do módulo \\\"%s\\\"!\", quiz_id, module->name);\n    return 0;\n}\n\nint add_question_to_quiz(int professor_id, int quiz_id, const char* question_text, const char* option1, const char* option2, const char* option3, const char* option4, int correct_option, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Encontrar o questionário\n    Quiz* quiz = NULL;\n    for (int i = 0; i < global_data.num_quizzes; i++) {\n        if (global_data.quizzes[i].id == quiz_id) {\n            quiz = &global_data.quizzes[i];\n            break;\n        }\n    }\n    if (!quiz) {\n        snprintf(message_buffer, buffer_size, \"Erro: Questionário com ID %d não encontrado.\", quiz_id);\n        return -1;\n    }\n\n    // Encontrar o módulo do questionário\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == quiz->module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(message_buffer, buffer_size, \"Erro interno: Módulo do questionário com ID %d não encontrado.\", quiz->module_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo do questionário\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo do questionário com ID %d.\", professor_id, module->subject_id);\n        return -1;\n    }\n\n    // Verificar limite de perguntas para o questionário\n    if (quiz->num_questions >= MAX_QUESTIONS_PER_QUIZ) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite de perguntas atingido para o questionário \\\"%s\\\".\", quiz->title);\n        return -1;\n    }\n\n    // Validar opção correta\n    if (correct_option < 0 || correct_option > 3) {\n        snprintf(message_buffer, buffer_size, \"Erro: Opção correta deve ser entre 0 e 3.\");\n        return -1;\n    }\n\n    // Adicionar nova pergunta\n    Question new_question;\n    // ID da pergunta pode ser incremental dentro do quiz ou global se necessário\n    // Por simplicidade, usaremos o índice dentro do quiz como ID temporário\n    new_question.id = quiz->num_questions;\n    strncpy(new_question.text, question_text, MAX_STR_LEN - 1);\n    new_question.text[MAX_STR_LEN - 1] = '\\0';\n    strncpy(new_question.options[0], option1, MAX_STR_LEN - 1);\n    new_question.options[0][MAX_STR_LEN - 1] = '\\0';\n    strncpy(new_question.options[1], option2, MAX_STR_LEN - 1);\n    new_question.options[1][MAX_STR_LEN - 1] = '\\0';\n    strncpy(new_question.options[2], option3, MAX_STR_LEN - 1);\n    new_question.options[2][MAX_STR_LEN - 1] = '\\0';\n    strncpy(new_question.options[3], option4, MAX_STR_LEN - 1);\n    new_question.options[3][MAX_STR_LEN - 1] = '\\0';\n    new_question.correct_option = correct_option;\n\n    quiz->questions[quiz->num_questions++] = new_question;\n\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Pergunta adicionada ao questionário \\\"%s\\\" com sucesso!\", quiz->title);\n    return 0;\n}\n\nint edit_question(int professor_id, int quiz_id, int question_id, const char* new_text, const char* new_option1, const char* new_option2, const char* new_option3, const char* new_option4, int new_correct_option, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Encontrar o questionário\n    Quiz* quiz = NULL;\n    for (int i = 0; i < global_data.num_quizzes; i++) {\n        if (global_data.quizzes[i].id == quiz_id) {\n            quiz = &global_data.quizzes[i];\n            break;\n        }\n    }\n    if (!quiz) {\n        snprintf(message_buffer, buffer_size, \"Erro: Questionário com ID %d não encontrado.\", quiz_id);\n        return -1;\n    }\n\n    // Encontrar o módulo do questionário\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == quiz->module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(message_buffer, buffer_size, \"Erro interno: Módulo do questionário com ID %d não encontrado.\", quiz->module_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo do questionário\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo do questionário com ID %d.\", professor_id, module->subject_id);\n        return -1;\n    }\n\n    // Encontrar a pergunta\n    Question* question = NULL;\n    if (question_id >= 0 && question_id < quiz->num_questions) {\n        question = &quiz->questions[question_id];\n    }\n    if (!question) {\n        snprintf(message_buffer, buffer_size, \"Erro: Pergunta com ID %d não encontrada no questionário %s.\", question_id, quiz->title);\n        return -1;\n    }\n\n    // Validar nova opção correta\n    if (new_correct_option < 0 || new_correct_option > 3) {\n        snprintf(message_buffer, buffer_size, \"Erro: Nova opção correta deve ser entre 0 e 3.\");\n        return -1;\n    }\n\n    strncpy(question->text, new_text, MAX_STR_LEN - 1);\n    question->text[MAX_STR_LEN - 1] = '\\0';\n    strncpy(question->options[0], new_option1, MAX_STR_LEN - 1);\n    question->options[0][MAX_STR_LEN - 1] = '\\0';\n    strncpy(question->options[1], new_option2, MAX_STR_LEN - 1);\n    question->options[1][MAX_STR_LEN - 1] = '\\0';\n    strncpy(question->options[2], new_option3, MAX_STR_LEN - 1);\n    question->options[2][MAX_STR_LEN - 1] = '\\0';\n    strncpy(question->options[3], new_option4, MAX_STR_LEN - 1);\n    question->options[3][MAX_STR_LEN - 1] = '\\0';\n    question->correct_option = new_correct_option;\n\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Pergunta com ID %d do questionário \\\"%s\\\" atualizada com sucesso!\", question_id, quiz->title);\n    return 0;\n}\n\nint remove_question(int professor_id, int quiz_id, int question_id, char* message_buffer, int buffer_size) {\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    // Encontrar o questionário\n    Quiz* quiz = NULL;\n    for (int i = 0; i < global_data.num_quizzes; i++) {\n        if (global_data.quizzes[i].id == quiz_id) {\n            quiz = &global_data.quizzes[i];\n            break;;\n        }\n    }\n    if (!quiz) {\n        snprintf(message_buffer, buffer_size, \"Erro: Questionário com ID %d não encontrado.\", quiz_id);\n        return -1;\n    }\n\n    // Encontrar o módulo do questionário\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == quiz->module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(message_buffer, buffer_size, \"Erro interno: Módulo do questionário com ID %d não encontrado.\", quiz->module_id);\n        return -1;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo do questionário\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo do questionário com ID %d.\", professor_id, module->subject_id);\n        return -1;\n    }\n\n    // Remover a pergunta do array de perguntas do questionário\n    if (question_id < 0 || question_id >= quiz->num_questions) {\n        snprintf(message_buffer, buffer_size, \"Erro: Pergunta com ID %d não encontrada no questionário %s.\", question_id, quiz->title);\n        return -1;\n    }\n\n    for (int i = question_id; i < quiz->num_questions - 1; i++) {\n        quiz->questions[i] = quiz->questions[i+1];\n    }\n    quiz->num_questions--;\n\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Pergunta com ID %d removida com sucesso do questionário \\\"%s\\\"!\", question_id, quiz->title);\n    return 0;\n}\n\nvoid list_module_quizzes(int professor_id, int module_id, char* data_buffer, int buffer_size) {\n    data_buffer[0] = '\\0'; // Garante que o buffer de saída comece vazio\n\n    // Verificar se o professor existe\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(data_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return;\n    }\n\n    // Encontrar o módulo\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; i++) {\n        if (global_data.modules[i].id == module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(data_buffer, buffer_size, \"Erro: Módulo com ID %d não encontrado.\", module_id);\n        return;\n    }\n\n    // Verificar se o professor está associado à matéria do módulo\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == module->subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    int is_prof_assigned_to_subject = 0;\n    if (subject) {\n        for (int i = 0; i < prof->num_assigned_subjects; i++) {\n            if (prof->assigned_subjects[i] == subject->id) {\n                is_prof_assigned_to_subject = 1;\n                break;\n            }\n        }\n    }\n\n    if (!is_prof_assigned_to_subject) {\n        snprintf(data_buffer, buffer_size, \"Erro: Professor com ID %d não está atribuído à matéria do módulo com ID %d.\", professor_id, module->subject_id);\n        return;\n    }\n\n    if (module->num_quizzes == 0) {\n        snprintf(data_buffer, buffer_size, \"Nenhum questionário cadastrado para o módulo \\\"%s\\\" (ID: %d).\", module->name, module_id);\n        return;\n    }\n\n    char temp_buffer[256];\n    int offset = 0;\n\n    offset += snprintf(data_buffer + offset, buffer_size - offset, \"Questionários do módulo \\\"%s\\\" (ID: %d):\\n\", module->name, module_id);\n\n    for (int i = 0; i < module->num_quizzes; i++) {\n        int quiz_id = module->quiz_ids[i];\n        Quiz* quiz = NULL;\n        for (int j = 0; j < global_data.num_quizzes; j++) {\n            if (global_data.quizzes[j].id == quiz_id) {\n                quiz = &global_data.quizzes[j];\n                break;\n            }\n        }\n\n        if (quiz) {\n            snprintf(temp_buffer, sizeof(temp_buffer), \"  - ID: %d, Título: %s\\n\",\n                     quiz->id, quiz->title);\n            if ((size_t)offset + strlen(temp_buffer) < (size_t)buffer_size) {\n                strcat(data_buffer + offset, temp_buffer);\n                offset += strlen(temp_buffer);\n            } else {\n                strcat(data_buffer, \"... (lista truncada)\");\n                break;\n            }\n        }\n    }\n}","size_bytes":59436},"replit.md":{"content":"# Sistema Acadêmico PIM\n\n## Visão Geral\nEste é um sistema acadêmico desenvolvido em C com arquitetura cliente-servidor. O sistema permite o gerenciamento de alunos, professores, disciplinas, notas e frequências.\n\n## Data da Importação\n- **Data**: 01 de Novembro de 2025\n- **Origem**: GitHub Import\n\n## Arquitetura do Projeto\n\n### Estrutura\nO projeto está organizado em módulos:\n- **admin/**: Funcionalidades administrativas (CRUD de usuários)\n- **student/**: Funcionalidades do aluno (visualizar notas, faltas)\n- **professor/**: Funcionalidades do professor (lançar notas, gerenciar turmas)\n- **server_logic/**: Lógica de negócios do servidor\n- **storage/**: Persistência de dados em arquivos\n- **common_utils/**: Funções utilitárias compartilhadas\n\n### Componentes\n- **Servidor**: `sistema_academico_server` - Porta 8080\n- **Cliente**: `sistema_academico_client` - Conecta ao servidor\n\n## Configuração do Ambiente Replit\n\n### Compilação\nO projeto usa Make para compilação:\n```bash\nmake clean   # Limpa builds antigos\nmake         # Compila servidor e cliente\n```\n\n### Execução\nO servidor é executado automaticamente através do workflow configurado:\n- **Workflow**: `servidor`\n- **Porta**: 8080\n- **Comando**: `./sistema_academico_server`\n\nPara executar o cliente manualmente:\n```bash\n./sistema_academico_client\n```\n\n### Persistência de Dados\nOs dados são armazenados em:\n- `system_data.dat` - Dados binários do sistema\n- `alunos.json`, `disciplinas.json`, `notas.json` - Arquivos JSON auxiliares\n\n## Modificações para Replit\n\n### Alterações Realizadas\n1. **Makefile atualizado**: Removido flag `-lws2_32` (específico do Windows) para compatibilidade com Linux\n2. **Workflow configurado**: Servidor executa automaticamente na porta 8080\n3. **Gitignore criado**: Ignora executáveis, arquivos objeto e DLLs\n\n### Compatibilidade\nO código fonte mantém compatibilidade multiplataforma:\n- Linux: Usa sockets POSIX padrão\n- Windows: Usa Winsock2 (com preprocessador `#ifdef _WIN32`)\n\n## Estado Atual\n- ✅ Projeto compilado com sucesso\n- ✅ Servidor rodando na porta 8080\n- ✅ Dados carregados corretamente\n- ✅ Pronto para conexões de clientes\n\n## Próximos Passos\nPara usar o sistema:\n1. O servidor já está rodando automaticamente\n2. Execute o cliente com: `./sistema_academico_client`\n3. Conecte-se ao servidor em localhost:8080\n4. Acesse as funcionalidades através dos menus do cliente\n\n## Tecnologias\n- **Linguagem**: C (C11)\n- **Compilador**: GCC\n- **Sistema de Build**: Make\n- **Rede**: Sockets TCP/IP\n- **Persistência**: Arquivos binários e JSON\n","size_bytes":2595},"src/main.c":{"content":"#include <stdio.h>\n#include <stdlib.h>\n#include \"server.h\" // Inclui o cabeçalho do servidor\n\n#define DEFAULT_PORT 8080\n\nint main() {\n    printf(\"Iniciando o servidor de sistema acadêmico...\\n\");\n    start_server(DEFAULT_PORT);\n    return 0;\n}\n","size_bytes":246},"src/admin/admin.c":{"content":"#include \"admin/admin.h\"\n#include \"common_utils.h\"\n#include \"storage/storage.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// Implementação das funções de gerenciamento de Professores\nint add_professor(const char* name, const char* email, const char* password, char* message_buffer, int buffer_size) {\n    if (global_data.num_professors >= MAX_PROFESSORS) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite de professores atingido.\");\n        return -1;\n    }\n\n    Professor new_prof;\n    new_prof.id = global_data.num_professors + 1; // ID simples incremental\n    strncpy(new_prof.name, name, MAX_STR_LEN - 1);\n    new_prof.name[MAX_STR_LEN - 1] = '\\0';\n    strncpy(new_prof.email, email, MAX_EMAIL_LEN - 1);\n    new_prof.email[MAX_EMAIL_LEN - 1] = '\\0';\n    strncpy(new_prof.password, password, MAX_PASSWORD_LEN - 1);\n    new_prof.password[MAX_PASSWORD_LEN - 1] = '\\0';\n\n    // Lógica para atribuir turmas e matérias (simplificado por enquanto)\n    new_prof.num_assigned_classes = 0;\n    new_prof.num_assigned_subjects = 0;\n\n    global_data.professors[global_data.num_professors] = new_prof;\n    global_data.num_professors++;\n    snprintf(message_buffer, buffer_size, \"Professor %s adicionado com sucesso!\", new_prof.name);\n    return 0;\n}\n\nvoid list_professors(char* data_buffer, int buffer_size) {\n    if (global_data.num_professors == 0) {\n        snprintf(data_buffer, buffer_size, \"Nenhum professor cadastrado.\");\n        return;\n    }\n\n    char temp_buffer[200]; // Buffer temporário para cada linha de professor\n    data_buffer[0] = '\\0'; // Garante que o buffer de saída comece vazio\n\n    for (int i = 0; i < global_data.num_professors; i++) {\n        snprintf(temp_buffer, sizeof(temp_buffer), \"ID: %d, Nome: %s, Email: %s\\n\", \n                 global_data.professors[i].id, \n                 global_data.professors[i].name, \n                 global_data.professors[i].email);\n        // Concatena ao data_buffer, garantindo que não ultrapasse o tamanho\n        if (strlen(data_buffer) + strlen(temp_buffer) < (size_t)buffer_size) {\n            strcat(data_buffer, temp_buffer);\n        } else {\n            strcat(data_buffer, \"... (lista truncada)\");\n            break;\n        }\n    }\n}\n\nint edit_professor(int id, const char* name, const char* email, const char* password, char* message_buffer, int buffer_size) {\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == id) {\n            strncpy(global_data.professors[i].name, name, MAX_STR_LEN - 1);\n            global_data.professors[i].name[MAX_STR_LEN - 1] = '\\0';\n            strncpy(global_data.professors[i].email, email, MAX_EMAIL_LEN - 1);\n            global_data.professors[i].email[MAX_EMAIL_LEN - 1] = '\\0';\n            strncpy(global_data.professors[i].password, password, MAX_PASSWORD_LEN - 1);\n            global_data.professors[i].password[MAX_PASSWORD_LEN - 1] = '\\0';\n            snprintf(message_buffer, buffer_size, \"Professor com ID %d atualizado com sucesso!\", id);\n            return 0;\n        }\n    }\n    snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", id);\n    return -1;\n}\n\nint remove_professor(int id, char* message_buffer, int buffer_size) {\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == id) {\n            // Move os últimos professores para preencher o espaço\n            for (int j = i; j < global_data.num_professors - 1; j++) {\n                global_data.professors[j] = global_data.professors[j+1];\n            }\n            global_data.num_professors--;\n            snprintf(message_buffer, buffer_size, \"Professor com ID %d removido com sucesso!\", id);\n            return 0;\n        }\n    }\n    snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", id);\n    return -1;\n}\n\n// Implementação das funções de gerenciamento de Turmas\nint add_class(const char* name, char* message_buffer, int buffer_size) {\n    if (global_data.num_classes >= MAX_CLASSES) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite de turmas atingido.\");\n        return -1;\n    }\n\n    Class new_class;\n    new_class.id = global_data.num_classes + 1;\n    strncpy(new_class.name, name, MAX_STR_LEN - 1);\n    new_class.name[MAX_STR_LEN - 1] = '\\0';\n    new_class.num_students = 0;\n    // Professor ID opcional por enquanto\n    new_class.professor_id = 0;\n\n    global_data.classes[global_data.num_classes] = new_class;\n    global_data.num_classes++;\n    snprintf(message_buffer, buffer_size, \"Turma %s adicionada com sucesso!\", new_class.name);\n    return 0;\n}\n\nvoid list_classes(char* data_buffer, int buffer_size) {\n    if (global_data.num_classes == 0) {\n        snprintf(data_buffer, buffer_size, \"Nenhuma turma cadastrada.\");\n        return;\n    }\n\n    char temp_buffer[200]; // Buffer temporário para cada linha de turma\n    data_buffer[0] = '\\0'; // Garante que o buffer de saída comece vazio\n\n    for (int i = 0; i < global_data.num_classes; i++) {\n        snprintf(temp_buffer, sizeof(temp_buffer), \"ID: %d, Nome: %s\\n\", \n                 global_data.classes[i].id, \n                 global_data.classes[i].name);\n        // Concatena ao data_buffer, garantindo que não ultrapasse o tamanho\n        if (strlen(data_buffer) + strlen(temp_buffer) < (size_t)buffer_size) {\n            strcat(data_buffer, temp_buffer);\n        } else {\n            strcat(data_buffer, \"... (lista truncada)\");\n            break;\n        }\n    }\n}\n\nint edit_class(int id, const char* name, char* message_buffer, int buffer_size) {\n    for (int i = 0; i < global_data.num_classes; i++) {\n        if (global_data.classes[i].id == id) {\n            strncpy(global_data.classes[i].name, name, MAX_STR_LEN - 1);\n            global_data.classes[i].name[MAX_STR_LEN - 1] = '\\0';\n            snprintf(message_buffer, buffer_size, \"Turma com ID %d atualizada com sucesso!\", id);\n            return 0;\n        }\n    }\n    snprintf(message_buffer, buffer_size, \"Erro: Turma com ID %d não encontrada.\", id);\n    return -1;\n}\n\nint remove_class(int id, char* message_buffer, int buffer_size) {\n    for (int i = 0; i < global_data.num_classes; i++) {\n        if (global_data.classes[i].id == id) {\n            // Move as últimas turmas para preencher o espaço\n            for (int j = i; j < global_data.num_classes - 1; j++) {\n                global_data.classes[j] = global_data.classes[j+1];\n            }\n            global_data.num_classes--;\n            snprintf(message_buffer, buffer_size, \"Turma com ID %d removida com sucesso!\", id);\n            return 0;\n        }\n    }\n    snprintf(message_buffer, buffer_size, \"Erro: Turma com ID %d não encontrada.\", id);\n    return -1;\n}\n\n// Implementação das funções de gerenciamento de Alunos\nint add_student(const char* name, const char* email, const char* password, int class_id, char* message_buffer, int buffer_size) {\n    if (global_data.num_students >= MAX_STUDENTS) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite de alunos atingido.\");\n        return -1;\n    }\n\n    // Verificar se a turma existe\n    int class_found = 0;\n    for (int i = 0; i < global_data.num_classes; i++) {\n        if (global_data.classes[i].id == class_id) {\n            class_found = 1;\n            break;\n        }\n    }\n    if (!class_found) {\n        snprintf(message_buffer, buffer_size, \"Erro: Turma com ID %d não encontrada.\", class_id);\n        return -1;\n    }\n\n    Student new_student;\n    new_student.id = global_data.num_students + 1;\n    strncpy(new_student.name, name, MAX_STR_LEN - 1);\n    new_student.name[MAX_STR_LEN - 1] = '\\0';\n    strncpy(new_student.email, email, MAX_EMAIL_LEN - 1);\n    new_student.email[MAX_EMAIL_LEN - 1] = '\\0';\n    strncpy(new_student.password, password, MAX_PASSWORD_LEN - 1);\n    new_student.password[MAX_PASSWORD_LEN - 1] = '\\0';\n    new_student.class_id = class_id;\n    new_student.num_grades = 0;\n    new_student.num_absences = 0;\n\n    global_data.students[global_data.num_students] = new_student;\n    global_data.num_students++;\n    snprintf(message_buffer, buffer_size, \"Aluno %s adicionado com sucesso na turma %d!\", new_student.name, class_id);\n    return 0;\n}\n\nvoid list_students(char* data_buffer, int buffer_size) {\n    if (global_data.num_students == 0) {\n        snprintf(data_buffer, buffer_size, \"Nenhum aluno cadastrado.\");\n        return;\n    }\n\n    char temp_buffer[200]; // Buffer temporário para cada linha de aluno\n    data_buffer[0] = '\\0'; // Garante que o buffer de saída comece vazio\n\n    for (int i = 0; i < global_data.num_students; i++) {\n        snprintf(temp_buffer, sizeof(temp_buffer), \"ID: %d, Nome: %s, Email: %s, Turma ID: %d\\n\", \n                 global_data.students[i].id, \n                 global_data.students[i].name, \n                 global_data.students[i].email,\n                 global_data.students[i].class_id);\n        // Concatena ao data_buffer, garantindo que não ultrapasse o tamanho\n        if (strlen(data_buffer) + strlen(temp_buffer) < (size_t)buffer_size) {\n            strcat(data_buffer, temp_buffer);\n        } else {\n            strcat(data_buffer, \"... (lista truncada)\");\n            break;\n        }\n    }\n}\n\nint edit_student(int id, const char* name, const char* email, const char* password, int new_class_id, char* message_buffer, int buffer_size) {\n    // Verificar se a nova turma existe, se fornecida\n    if (new_class_id != 0) { // Assumindo 0 como ID de turma inválido/não fornecido\n        int class_found = 0;\n        for (int i = 0; i < global_data.num_classes; i++) {\n            if (global_data.classes[i].id == new_class_id) {\n                class_found = 1;\n                break;\n            }\n        }\n        if (!class_found) {\n            snprintf(message_buffer, buffer_size, \"Erro: Nova turma com ID %d não encontrada.\", new_class_id);\n            return -1;\n        }\n    }\n\n    for (int i = 0; i < global_data.num_students; i++) {\n        if (global_data.students[i].id == id) {\n            strncpy(global_data.students[i].name, name, MAX_STR_LEN - 1);\n            global_data.students[i].name[MAX_STR_LEN - 1] = '\\0';\n            strncpy(global_data.students[i].email, email, MAX_EMAIL_LEN - 1);\n            global_data.students[i].email[MAX_EMAIL_LEN - 1] = '\\0';\n            strncpy(global_data.students[i].password, password, MAX_PASSWORD_LEN - 1);\n            global_data.students[i].password[MAX_PASSWORD_LEN - 1] = '\\0';\n            if (new_class_id != 0) {\n                global_data.students[i].class_id = new_class_id;\n            }\n            snprintf(message_buffer, buffer_size, \"Aluno com ID %d atualizado com sucesso!\", id);\n            return 0;\n        }\n    }\n    snprintf(message_buffer, buffer_size, \"Erro: Aluno com ID %d não encontrado.\", id);\n    return -1;\n}\n\nint remove_student(int id, char* message_buffer, int buffer_size) {\n    for (int i = 0; i < global_data.num_students; i++) {\n        if (global_data.students[i].id == id) {\n            // Move os últimos alunos para preencher o espaço\n            for (int j = i; j < global_data.num_students - 1; j++) {\n                global_data.students[j] = global_data.students[j+1];\n            }\n            global_data.num_students--;\n            snprintf(message_buffer, buffer_size, \"Aluno com ID %d removido com sucesso!\", id);\n            return 0;\n        }\n    }\n    snprintf(message_buffer, buffer_size, \"Erro: Aluno com ID %d não encontrado.\", id);\n    return -1;\n}\n\n// Funções de Gerenciamento de Matérias/Turmas (agora para o Admin)\nint add_subject(const char* name, char* message_buffer, int buffer_size) {\n    if (global_data.num_subjects >= MAX_SUBJECTS_PER_PROF * MAX_PROFESSORS) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite de matérias atingido no sistema.\");\n        return -1;\n    }\n\n    Subject new_subject;\n    new_subject.id = (global_data.num_subjects > 0) ? global_data.subjects[global_data.num_subjects - 1].id + 1 : 1;\n    strncpy(new_subject.name, name, MAX_STR_LEN - 1);\n    new_subject.name[MAX_STR_LEN - 1] = '\\0';\n    new_subject.professor_id = 0; // Ninguém atribuído inicialmente\n    new_subject.num_modules = 0;\n\n    global_data.subjects[global_data.num_subjects] = new_subject;\n    global_data.num_subjects++;\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Matéria '%s' (ID: %d) criada com sucesso!\", new_subject.name, new_subject.id);\n    return 0;\n}\n\nint admin_assign_subject_to_professor(int professor_id, int subject_id, char* message_buffer, int buffer_size) {\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; i++) {\n        if (global_data.subjects[i].id == subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n\n    // Se a matéria não existe, criá-la (simplificado, poderia ser um comando ADMIN)\n    if (!subject) {\n        if (global_data.num_subjects >= MAX_SUBJECTS_PER_PROF * MAX_PROFESSORS) {\n            snprintf(message_buffer, buffer_size, \"Erro: Limite de matérias atingido no sistema.\");\n            return -1;\n        }\n        Subject new_subject;\n        new_subject.id = (global_data.num_subjects > 0) ? global_data.subjects[global_data.num_subjects - 1].id + 1 : 1; // ID incremental\n        snprintf(new_subject.name, MAX_STR_LEN, \"Nova Matéria %d\", new_subject.id); // Nome genérico\n        new_subject.professor_id = professor_id;\n        new_subject.num_modules = 0;\n        global_data.subjects[global_data.num_subjects] = new_subject;\n        subject = &global_data.subjects[global_data.num_subjects];\n        global_data.num_subjects++;\n        //snprintf(message_buffer, buffer_size, \"Matéria com ID %d criada automaticamente.\\n\", new_subject.id); // Mensagem adicional se criado\n    }\n\n    if (prof->num_assigned_subjects >= MAX_SUBJECTS_PER_PROF) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor já atribuído ao número máximo de matérias (%d).\", MAX_SUBJECTS_PER_PROF);\n        return -1;\n    }\n\n    for (int i = 0; i < prof->num_assigned_subjects; i++) {\n        if (prof->assigned_subjects[i] == subject_id) {\n            snprintf(message_buffer, buffer_size, \"Erro: Matéria com ID %d já atribuída ao professor %s.\", subject_id, prof->name);\n            return -1;\n        }\n    }\n\n    prof->assigned_subjects[prof->num_assigned_subjects++] = subject_id;\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Matéria com ID %d atribuída ao professor %s com sucesso!\", subject_id, prof->name);\n    return 0;\n}\n\nint admin_unassign_subject_from_professor(int professor_id, int subject_id, char* message_buffer, int buffer_size) {\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    int found_index = -1;\n    for (int i = 0; i < prof->num_assigned_subjects; i++) {\n        if (prof->assigned_subjects[i] == subject_id) {\n            found_index = i;\n            break;\n        }\n    }\n\n    if (found_index == -1) {\n        snprintf(message_buffer, buffer_size, \"Erro: Matéria com ID %d não está atribuída ao professor %s.\", subject_id, prof->name);\n        return -1;\n    }\n\n    // Remove a matéria movendo os elementos seguintes\n    for (int i = found_index; i < prof->num_assigned_subjects - 1; i++) {\n        prof->assigned_subjects[i] = prof->assigned_subjects[i+1];\n    }\n    prof->num_assigned_subjects--;\n\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Matéria com ID %d desatribuída do professor %s com sucesso!\", subject_id, prof->name);\n    return 0;\n}\n\nint admin_assign_class_to_professor(int professor_id, int class_id, char* message_buffer, int buffer_size) {\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    Class* class_to_assign = NULL;\n    for (int i = 0; i < global_data.num_classes; i++) {\n        if (global_data.classes[i].id == class_id) {\n            class_to_assign = &global_data.classes[i];\n            break;\n        }\n    }\n    if (!class_to_assign) {\n        snprintf(message_buffer, buffer_size, \"Erro: Turma com ID %d não encontrada.\", class_id);\n        return -1;\n    }\n\n    if (prof->num_assigned_classes >= MAX_CLASSES_PER_PROF) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor já atribuído ao número máximo de turmas (%d).\", MAX_CLASSES_PER_PROF);\n        return -1;\n    }\n\n    for (int i = 0; i < prof->num_assigned_classes; i++) {\n        if (prof->assigned_classes[i] == class_id) {\n            snprintf(message_buffer, buffer_size, \"Erro: Turma com ID %d já atribuída ao professor %s.\", class_id, prof->name);\n            return -1;\n        }\n    }\n\n    prof->assigned_classes[prof->num_assigned_classes++] = class_id;\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Turma com ID %d atribuída ao professor %s com sucesso!\", class_id, prof->name);\n    return 0;\n}\n\nint admin_unassign_class_from_professor(int professor_id, int class_id, char* message_buffer, int buffer_size) {\n    Professor* prof = NULL;\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (global_data.professors[i].id == professor_id) {\n            prof = &global_data.professors[i];\n            break;\n        }\n    }\n    if (!prof) {\n        snprintf(message_buffer, buffer_size, \"Erro: Professor com ID %d não encontrado.\", professor_id);\n        return -1;\n    }\n\n    int found_index = -1;\n    for (int i = 0; i < prof->num_assigned_classes; i++) {\n        if (prof->assigned_classes[i] == class_id) {\n            found_index = i;\n            break;\n        }\n    }\n\n    if (found_index == -1) {\n        snprintf(message_buffer, buffer_size, \"Erro: Turma com ID %d não está atribuída ao professor %s.\", class_id, prof->name);\n        return -1;\n    }\n\n    // Remove a turma movendo os elementos seguintes\n    for (int i = found_index; i < prof->num_assigned_classes - 1; i++) {\n        prof->assigned_classes[i] = prof->assigned_classes[i+1];\n    }\n    prof->num_assigned_classes--;\n\n    save_data(\"system_data.dat\");\n    snprintf(message_buffer, buffer_size, \"Turma com ID %d desatribuída do professor %s com sucesso!\", class_id, prof->name);\n    return 0;\n}\n\n// Funções de Gerenciamento de Matrículas de Alunos por Admin\nint admin_enroll_student_in_subject(int student_id, int subject_id, char* message_buffer, int buffer_size) {\n    Student* student = get_student_by_id_ptr(student_id);\n    if (!student) {\n        snprintf(message_buffer, buffer_size, \"Erro: Aluno com ID %d não encontrado.\", student_id);\n        return -1;\n    }\n\n    Subject* subject = get_subject_by_id_ptr(subject_id);\n    if (!subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Matéria com ID %d não encontrada.\", subject_id);\n        return -1;\n    }\n\n    // Verificar se o aluno já está matriculado nesta matéria\n    for (int j = 0; j < student->num_enrolled_subjects; ++j) {\n        if (student->enrolled_subject_ids[j] == subject_id) {\n            snprintf(message_buffer, buffer_size, \"Erro: Aluno já matriculado na matéria '%s'.\", subject->name);\n            return -1;\n        }\n    }\n\n    if (student->num_enrolled_subjects >= MAX_ENROLLED_SUBJECTS_PER_STUDENT) {\n        snprintf(message_buffer, buffer_size, \"Erro: Limite de matérias (%d) atingido para o aluno com ID %d.\", MAX_ENROLLED_SUBJECTS_PER_STUDENT, student_id);\n        return -1;\n    }\n\n    student->enrolled_subject_ids[student->num_enrolled_subjects] = subject_id;\n    student->num_enrolled_subjects += 1;\n\n    if (save_data(\"system_data.dat\") != 0) {\n        student->num_enrolled_subjects -= 1;\n        snprintf(message_buffer, buffer_size, \"Falha ao salvar dados após matricular o aluno.\");\n        return -1;\n    }\n\n    snprintf(message_buffer, buffer_size, \"Aluno com ID %d matriculado com sucesso na matéria '%s' (ID: %d).\", student_id, subject->name, subject_id);\n    return 0;\n}\n\nint admin_unenroll_student_from_subject(int student_id, int subject_id, char* message_buffer, int buffer_size) {\n    Student* student = get_student_by_id_ptr(student_id);\n    if (!student) {\n        snprintf(message_buffer, buffer_size, \"Erro: Aluno com ID %d não encontrado.\", student_id);\n        return -1;\n    }\n\n    Subject* subject = get_subject_by_id_ptr(subject_id);\n    if (!subject) {\n        snprintf(message_buffer, buffer_size, \"Erro: Matéria com ID %d não encontrada.\", subject_id);\n        return -1;\n    }\n\n    int found_index = -1;\n    for (int j = 0; j < student->num_enrolled_subjects; ++j) {\n        if (student->enrolled_subject_ids[j] == subject_id) {\n            found_index = j;\n            break;\n        }\n    }\n\n    if (found_index == -1) {\n        snprintf(message_buffer, buffer_size, \"Erro: Aluno com ID %d não está matriculado na matéria '%s' (ID: %d).\", student_id, subject->name, subject_id);\n        return -1;\n    }\n\n    for (int k = found_index; k < student->num_enrolled_subjects - 1; ++k) {\n        student->enrolled_subject_ids[k] = student->enrolled_subject_ids[k + 1];\n    }\n    student->num_enrolled_subjects--;\n\n    if (save_data(\"system_data.dat\") != 0) {\n        // Reverter em caso de falha de salvamento (simplificado)\n        snprintf(message_buffer, buffer_size, \"Falha ao salvar dados após desmatricular o aluno.\");\n        return -1;\n    }\n\n    snprintf(message_buffer, buffer_size, \"Aluno com ID %d desmatriculado com sucesso da matéria '%s' (ID: %d).\", student_id, subject->name, subject_id);\n    return 0;\n}\n\nvoid admin_list_student_subjects(int student_id, char* data_buffer, int buffer_size) {\n    data_buffer[0] = '\\0';\n    Student* student = get_student_by_id_ptr(student_id);\n    if (!student) {\n        snprintf(data_buffer, buffer_size, \"Erro: Aluno com ID %d não encontrado.\", student_id);\n        return;\n    }\n\n    char temp_buffer[MAX_STR_LEN * 2];\n    if (student->num_enrolled_subjects <= 0) {\n        snprintf(data_buffer, buffer_size, \"Aluno com ID %d não está matriculado em nenhuma matéria.\\n\", student_id);\n        return;\n    }\n\n    snprintf(data_buffer, buffer_size, \"Matérias Matriculadas para o Aluno %d (%s):\\n\", student->id, student->name);\n    for (int i = 0; i < student->num_enrolled_subjects; ++i) {\n        int sid = student->enrolled_subject_ids[i];\n        Subject* subject = get_subject_by_id_ptr(sid);\n        if (subject) {\n            snprintf(temp_buffer, sizeof(temp_buffer), \"- ID: %d, Nome: %s\\n\", subject->id, subject->name);\n        } else {\n            snprintf(temp_buffer, sizeof(temp_buffer), \"- ID: %d, Nome: Desconhecida (Erro)\\n\", sid);\n        }\n        if (strlen(data_buffer) + strlen(temp_buffer) < (size_t)buffer_size) {\n            strcat(data_buffer, temp_buffer);\n        } else {\n            strcat(data_buffer, \"... (lista truncada)\\n\");\n            break;\n        }\n    }\n}","size_bytes":23823},"README.md":{"content":"# Documentação do Projeto PIM\n\nEste documento tem como objetivo fornecer um mapa para entender a estrutura de pastas e a funcionalidade de cada arquivo neste projeto.\n\n## Estrutura de Pastas\n\n```\nPIM/\n├── build/                        # Arquivos de objeto e executáveis gerados pela compilação\n├── src/                          # Código fonte do projeto\n│   ├── admin/                    # Módulo para funcionalidades administrativas (ex: CRUD de usuários)\n│   │   ├── admin.c               # Implementação das funções administrativas\n│   │   └── admin.h               # Definições de estruturas e protótipos para o módulo admin\n│   ├── client/                   # Módulo do cliente (interface do usuário)\n│   │   ├── client_main.c         # Ponto de entrada principal do cliente\n│   │   ├── client.c              # Funções de comunicação e lógica do cliente\n│   │   └── client.h              # Definições e protótipos para o módulo cliente\n│   ├── common_utils/             # Funções utilitárias comuns usadas por cliente e servidor\n│   │   ├── common_utils.c        # Implementação das funções utilitárias\n│   │   └── common_utils.h        # Definições e protótipos para as utilidades comuns\n│   ├── models.h                  # Definições de estruturas de dados para as entidades (ex: Aluno, Professor, Disciplina)\n│   ├── professor/                # Módulo para funcionalidades do professor\n│   │   ├── professor.c           # Implementação das funções do professor\n│   │   └── professor.h           # Definições e protótipos para o módulo professor\n│   ├── protocol.h                # Definições do protocolo de comunicação entre cliente e servidor\n│   ├── server_logic/             # Lógica de negócio do servidor\n│   │   ├── server_logic.c        # Implementação da lógica do servidor\n│   │   └── server_logic.h        # Definições e protótipos para a lógica do servidor\n│   ├── server.c                  # Implementação do servidor (gerenciamento de conexões)\n│   ├── server.h                  # Definições e protótipos para o módulo do servidor\n│   ├── storage/                  # Módulo de persistência de dados\n│   │   ├── storage.c             # Implementação das funções de armazenamento (leitura/escrita em arquivo)\n│   │   └── storage.h             # Definições e protótipos para o módulo de armazenamento\n│   └── main.c                    # Ponto de entrada principal para o servidor\n├── Makefile                      # Arquivo para automatizar a compilação do projeto\n├── sistema_academico_client.exe  # Executável do cliente\n├── sistema_academico_server.exe  # Executável do servidor\n├── system_data.dat               # Arquivo de dados persistente do sistema\n└── ... outros arquivos gerados ...\n```\n\n## Visão Geral dos Arquivos e Módulos\n\nEsta seção detalha a função de cada arquivo e módulo dentro do diretório `src/`.\n\n### Módulo `admin`\n*   `src/admin/admin.c`: Contém as implementações das funções relacionadas à administração do sistema, como o gerenciamento de usuários (alunos, professores, administradores), disciplinas e turmas.\n*   `src/admin/admin.h`: Define as estruturas de dados específicas para o módulo administrativo e declara os protótipos das funções implementadas em `admin.c`.\n\n### Módulo `client`\n*   `src/client_main.c`: É o arquivo principal que inicia a aplicação cliente. Ele lida com a inicialização da interface do usuário e o fluxo de controle inicial da aplicação cliente.\n*   `src/client.c`: Contém as funções que gerenciam a interação do usuário, como exibição de menus, coleta de entrada de dados e a comunicação efetiva com o servidor.\n*   `src/client.h`: Declara as estruturas e protótipos de funções usados pelo cliente, facilitando a organização e reuso do código em todo o módulo.\n\n### Módulo `common_utils`\n*   `src/common_utils.c`: Implementa funções utilitárias gerais que podem ser usadas tanto pelo cliente quanto pelo servidor, como manipulação de strings, validações de entrada ou outras operações comuns.\n*   `src/common_utils.h`: Contém as declarações para as funções utilitárias comuns, permitindo que outros módulos as incluam e usem em seus respectivos códigos.\n\n### Arquivos de Definição Global\n*   `src/models.h`: Define as estruturas de dados para as principais entidades do sistema, como `Aluno`, `Professor`, `Disciplina`, `Turma`, etc. Essas estruturas são fundamentais e usadas em todo o projeto para representar os dados.\n*   `src/protocol.h`: Define o formato das mensagens e comandos utilizados na comunicação entre o cliente e o servidor. Isso é crucial para garantir que ambos os lados entendam as informações que estão sendo trocadas de forma padronizada.\n\n### Módulo `professor`\n*   `src/professor/professor.c`: Contém as implementações das funções específicas para o perfil de professor, como lançamento de notas, gerenciamento de turmas associadas e visualização de informações de alunos.\n*   `src/professor/professor.h`: Define as estruturas e protótipos de funções para o módulo do professor, organizando o código e facilitando sua inclusão em outras partes do sistema.\n\n### Módulo `server`\n*   `src/server.c`: Implementa a lógica principal do servidor, incluindo o gerenciamento de conexões de clientes, a escuta por novas requisições e a coordenação geral da comunicação.\n*   `src/server.h`: Contém as declarações de funções e estruturas relacionadas ao servidor, servindo como uma interface para o módulo do servidor.\n\n### Módulo `server_logic`\n*   `src/server_logic/server_logic.c`: Implementa a lógica de negócios central do servidor. É responsável por processar as requisições dos clientes, interagir com o módulo de armazenamento e aplicar as regras de negócio do sistema.\n*   `src/server_logic/server_logic.h`: Define os protótipos de funções e estruturas utilizadas pela lógica do servidor, garantindo uma interface clara para a comunicação com outras partes do servidor.\n\n### Módulo `storage`\n*   `src/storage/storage.c`: Implementa as funções de persistência de dados, como leitura e escrita de informações em arquivos (ex: `system_data.dat`). É responsável por carregar o estado do sistema na inicialização e salvá-lo durante a execução.\n*   `src/storage/storage.h`: Declara as funções para o módulo de armazenamento de dados, permitindo que outros módulos solicitem operações de persistência de forma abstrata.\n\n### Ponto de Entrada do Servidor\n*   `src/main.c`: O ponto de entrada principal para a aplicação do servidor. Ele é responsável por inicializar o servidor, configurar os ouvintes de conexão e iniciar o ciclo de processamento de requisições de clientes.\n\n## Outros Arquivos Importantes\n\n*   `Makefile`: Um script que automatiza o processo de compilação do projeto. Ele define como os arquivos `.c` devem ser compilados em arquivos de objeto `.o` e, em seguida, linkados para criar os executáveis do cliente e do servidor.\n*   `system_data.dat`: Este arquivo é usado para armazenar os dados persistentes do sistema (alunos, professores, disciplinas, etc.) entre as execuções do programa. Ele é manipulado pelo módulo `storage`.\n","size_bytes":7539},"src/common_utils.c":{"content":"#include \"common_utils.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// Limpa o buffer de entrada\nvoid clear_input_buffer() {\n    int c;\n    while ((c = getchar()) != '\\n' && c != EOF);\n}\n\n// Obtém uma entrada de inteiro com validação\nint get_int_input(const char* prompt) {\n    int value;\n    char buffer[MAX_STR_LEN];\n    while (1) {\n        printf(\"%s\", prompt);\n        if (fgets(buffer, sizeof(buffer), stdin) != NULL) {\n            if (sscanf(buffer, \"%d\", &value) == 1) {\n                return value;\n            } else {\n                printf(\"Entrada inválida. Por favor, digite um número inteiro.\\n\");\n            }\n        } else {\n            printf(\"Erro na leitura da entrada.\\n\");\n            clear_input_buffer();\n        }\n    }\n}\n\n// Obtém uma entrada de string com validação de tamanho\nvoid get_string_input(const char* prompt, char* buffer, int max_len) {\n    while (1) {\n        printf(\"%s\", prompt);\n        if (fgets(buffer, max_len, stdin) != NULL) {\n            // Remove o '\\n' final se presente\n            buffer[strcspn(buffer, \"\\n\")] = 0;\n            if (strlen(buffer) > 0) {\n                return;\n            } else {\n                printf(\"A entrada não pode ser vazia. Tente novamente.\\n\");\n            }\n        } else {\n            printf(\"Erro na leitura da entrada.\\n\");\n            clear_input_buffer();\n        }\n    }\n}\n\n// Menus (implementação simples para o CLIENTE)\nvoid display_main_menu() {\n    printf(\"\\n--- MENU PRINCIPAL ---\\n\");\n    printf(\"1. Login\\n\");\n    printf(\"0. Sair\\n\");\n    printf(\"--------------------\\n\");\n}\n\nvoid display_admin_main_menu() {\n    printf(\"\\n--- MENU ADMINISTRADOR PRINCIPAL ---\\n\");\n    printf(\"1. Gerenciar Professores\\n\");\n    printf(\"2. Gerenciar Turmas\\n\");\n    printf(\"3. Gerenciar Alunos\\n\");\n    printf(\"4. Gerenciar Atribuições Professor-Matéria/Turma\\n\");\n    printf(\"0. Logout\\n\");\n    printf(\"-----------------------------------------------------------\\n\");\n}\n\nvoid display_admin_professor_menu() {\n    printf(\"\\n--- ADMIN: GERENCIAR PROFESSORES ---\\n\");\n    printf(\"1. Adicionar Professor\\n\");\n    printf(\"2. Listar Professores\\n\");\n    printf(\"3. Editar Professor\\n\");\n    printf(\"4. Remover Professor\\n\");\n    printf(\"0. Voltar ao Menu Admin Principal\\n\");\n    printf(\"------------------------------------\\n\");\n}\n\nvoid display_admin_class_menu() {\n    printf(\"\\n--- ADMIN: GERENCIAR TURMAS ---\\n\");\n    printf(\"1. Adicionar Turma\\n\");\n    printf(\"2. Listar Turmas\\n\");\n    printf(\"3. Editar Turma\\n\");\n    printf(\"4. Remover Turma\\n\");\n    printf(\"0. Voltar ao Menu Admin Principal\\n\");\n    printf(\"------------------------------\\n\");\n}\n\nvoid display_admin_student_menu() {\n    printf(\"\\n--- ADMIN: GERENCIAR ALUNOS ---\\n\");\n    printf(\"1. Adicionar Aluno\\n\");\n    printf(\"2. Listar Alunos\\n\");\n    printf(\"3. Editar Aluno\\n\");\n    printf(\"4. Remover Aluno\\n\");\n    printf(\"0. Voltar ao Menu Admin Principal\\n\");\n    printf(\"-------------------------------\\n\");\n}\n\nvoid display_professor_menu() {\n    printf(\"\\n--- MENU PROFESSOR ---\\n\");\n    printf(\"1. Minhas Matérias e Módulos (em desenvolvimento)\\n\");\n    printf(\"2. Postar Notas (em desenvolvimento)\\n\");\n    printf(\"0. Logout\\n\");\n    printf(\"--------------------\\n\");\n}\n\nvoid display_student_menu() {\n    printf(\"\\n--- MENU ALUNO ---\\n\");\n    printf(\"1. Consultar Meus Dados (Notas, Faltas) (em desenvolvimento)\\n\");\n    printf(\"2. Acessar Matérias e Módulos (em desenvolvimento)\\n\");\n    printf(\"0. Logout\\n\");\n    printf(\"----------------\\n\");\n}\n\n// Novo: Menu Principal do Professor\nvoid display_professor_main_menu() {\n    printf(\"\\n--- MENU PROFESSOR PRINCIPAL ---\\n\");\n    printf(\"1. Gerenciar Matérias e Turmas Atribuídas\\n\");\n    printf(\"2. Gerenciar Notas e Faltas de Alunos\\n\");\n    printf(\"3. Gerenciar Módulos e Aulas\\n\");\n    printf(\"4. Gerenciar Questionários\\n\");\n    printf(\"0. Logout\\n\");\n    printf(\"------------------------------------\\n\");\n    printf(\"Escolha uma opção: \");\n}\n\n// Novo: Menu de Gerenciamento de Matérias e Turmas do Professor\nvoid display_professor_subject_class_menu() {\n    printf(\"\\n--- PROFESSOR: GERENCIAR MATÉRIAS/TURMAS ---\\n\");\n    printf(\"1. Atribuir Matéria\\n\");\n    printf(\"2. Desatribuir Matéria\\n\");\n    printf(\"3. Atribuir Turma\\n\");\n    printf(\"4. Desatribuir Turma\\n\");\n    printf(\"5. Listar Matérias Atribuídas\\n\");\n    printf(\"6. Listar Turmas Atribuídas\\n\");\n    printf(\"0. Voltar ao Menu Professor Principal\\n\");\n    printf(\"------------------------------------------\\n\");\n    printf(\"Escolha uma opção: \");\n}\n\n// Novo: Menu de Gerenciamento de Notas e Faltas do Professor\nvoid display_professor_grades_absences_menu() {\n    printf(\"\\n--- PROFESSOR: GERENCIAR NOTAS/FALTAS ---\\n\");\n    printf(\"1. Lançar Nota\\n\");\n    printf(\"2. Registrar Falta\\n\");\n    printf(\"3. Visualizar Notas e Faltas de Aluno\\n\");\n    printf(\"0. Voltar ao Menu Professor Principal\\n\");\n    printf(\"----------------------------------------\\n\");\n    printf(\"Escolha uma opção: \");\n}\n\n// Novo: Menu de Gerenciamento de Módulos e Aulas do Professor\nvoid display_professor_modules_lessons_menu() {\n    printf(\"\\n--- PROFESSOR: GERENCIAR MÓDULOS/AULAS ---\\n\");\n    printf(\"1. Criar Módulo em Matéria\\n\");\n    printf(\"2. Listar Módulos de Matéria\\n\");\n    printf(\"3. Editar Módulo\\n\");\n    printf(\"4. Remover Módulo\\n\");\n    printf(\"5. Adicionar Aula a Módulo\\n\");\n    printf(\"6. Editar Aula\\n\");\n    printf(\"7. Remover Aula\\n\");\n    printf(\"8. Listar Aulas de Módulo\\n\");\n    printf(\"0. Voltar ao Menu Professor Principal\\n\");\n    printf(\"----------------------------------------\\n\");\n    printf(\"Escolha uma opção: \");\n}\n\n// Novo: Menu de Gerenciamento de Questionários do Professor\nvoid display_professor_quizzes_menu() {\n    printf(\"\\n--- PROFESSOR: GERENCIAR QUESTIONÁRIOS ---\\n\");\n    printf(\"1. Criar Questionário em Módulo\\n\");\n    printf(\"2. Editar Questionário\\n\");\n    printf(\"3. Remover Questionário\\n\");\n    printf(\"4. Adicionar Pergunta a Questionário\\n\");\n    printf(\"5. Editar Pergunta de Questionário\\n\");\n    printf(\"6. Remover Pergunta de Questionário\\n\");\n    printf(\"7. Listar Questionários de Módulo\\n\");\n    printf(\"0. Voltar ao Menu Professor Principal\\n\");\n    printf(\"----------------------------------------\\n\");\n    printf(\"Escolha uma opção: \");\n}\n\n// Novo: Menu de Gerenciamento de Matérias e Turmas para Administrador\nvoid display_admin_professor_subject_class_assignment_menu() {\n    printf(\"\\n--- ADMINISTRADOR: GERENCIAR ATRIBUIÇÕES PROFESSOR-MATÉRIA/TURMA ---\\n\");\n    printf(\"1. Atribuir Matéria a Professor\\n\");\n    printf(\"2. Desatribuir Matéria de Professor\\n\");\n    printf(\"3. Atribuir Turma a Professor\\n\");\n    printf(\"4. Desatribuir Turma de Professor\\n\");\n    printf(\"0. Voltar ao Menu Admin Principal\\n\");\n    printf(\"-----------------------------------------------------------\\n\");\n    printf(\"Escolha uma opção: \");\n}\n\n// Funções auxiliares de busca de entidades\nStudent* get_student_by_id_ptr(int student_id) {\n    for (int i = 0; i < global_data.num_students; ++i) {\n        if (global_data.students[i].id == student_id) {\n            return &global_data.students[i];\n        }\n    }\n    return NULL;\n}\n\nSubject* get_subject_by_id_ptr(int subject_id) {\n    for (int i = 0; i < global_data.num_subjects; ++i) {\n        if (global_data.subjects[i].id == subject_id) {\n            return &global_data.subjects[i];\n        }\n    }\n    return NULL;\n}\n\n// Função para gerar um novo ID único\nstatic int next_id_counter = 1; // Começa em 1\nint generate_next_id() {\n    return next_id_counter++;\n}","size_bytes":7606},"src/client_main.c":{"content":"#include <stdio.h>\n#include <stdlib.h>\n#include \"client.h\"\n\n#ifdef _WIN32\n#include <windows.h> // Necessário para SetConsoleOutputCP\n#endif\n\n#define SERVER_IP \"127.0.0.1\"\n#define SERVER_PORT 8080\n\nint main() {\n#ifdef _WIN32\n    // Configura a página de código do console para UTF-8 no Windows\n    SetConsoleOutputCP(CP_UTF8);\n    SetConsoleCP(CP_UTF8);\n#endif\n    printf(\"Iniciando o cliente de sistema acadêmico...\\n\");\n    start_client(SERVER_IP, SERVER_PORT);\n    return 0;\n}\n","size_bytes":483},"src/server_logic/server_logic.c":{"content":"#include \"server_logic/server_logic.h\"\n#include \"models.h\"\n#include \"protocol.h\" // Inclui definições de protocolo (ClientMessage, ServerResponse, CommandType)\n#include \"admin/admin.h\" // Inclui declarações das funções de administração\n#include \"storage/storage.h\" // Inclui declarações de funções de armazenamento\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"server.h\"\n#include \"professor/professor.h\"\n#include \"student/student.h\" // Incluir cabeçalho do aluno\n\n// Função para autenticar usuários (agora no lado do servidor)\nUser* authenticate_user(const char* email, const char* password, UserRole* role) {\n    static User logged_in_user; // Retorna uma cópia do usuário logado\n\n    // Tenta autenticar como Admin\n    for (int i = 0; i < global_data.num_admins; i++) {\n        if (strcmp(global_data.admins[i].email, email) == 0 && strcmp(global_data.admins[i].password, password) == 0) {\n            logged_in_user.id = global_data.admins[i].id;\n            strcpy(logged_in_user.email, global_data.admins[i].email);\n            strcpy(logged_in_user.password, global_data.admins[i].password);\n            logged_in_user.role = ROLE_ADMIN;\n            *role = ROLE_ADMIN;\n            return &logged_in_user;\n        }\n    }\n\n    // Tenta autenticar como Professor\n    for (int i = 0; i < global_data.num_professors; i++) {\n        if (strcmp(global_data.professors[i].email, email) == 0 && strcmp(global_data.professors[i].password, password) == 0) {\n            logged_in_user.id = global_data.professors[i].id;\n            strcpy(logged_in_user.email, global_data.professors[i].email);\n            strcpy(logged_in_user.password, global_data.professors[i].password);\n            logged_in_user.role = ROLE_PROFESSOR;\n            *role = ROLE_PROFESSOR;\n            return &logged_in_user;\n        }\n    }\n\n    // Tenta autenticar como Aluno\n    for (int i = 0; i < global_data.num_students; i++) {\n        if (strcmp(global_data.students[i].email, email) == 0 && strcmp(global_data.students[i].password, password) == 0) {\n            logged_in_user.id = global_data.students[i].id;\n            strcpy(logged_in_user.email, global_data.students[i].email);\n            strcpy(logged_in_user.password, global_data.students[i].password);\n            logged_in_user.role = ROLE_STUDENT;\n            *role = ROLE_STUDENT;\n            return &logged_in_user;\n        }\n    }\n\n    return NULL; // Autenticação falhou\n}\n\n// Nova função para lidar com o comando de login\nServerResponse handle_login_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro de autenticação desconhecido.\");\n\n    char email[MAX_EMAIL_LEN];\n    char password[MAX_PASSWORD_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        strncpy(email, token, MAX_EMAIL_LEN - 1);\n        email[MAX_EMAIL_LEN - 1] = '\\0';\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(password, token, MAX_PASSWORD_LEN - 1);\n            password[MAX_PASSWORD_LEN - 1] = '\\0';\n        } else {\n            strcpy(server_resp.message, \"Formato de login inválido: senha ausente.\");\n            return server_resp;\n        }\n    } else {\n        strcpy(server_resp.message, \"Formato de login inválido: email ausente.\");\n        return server_resp;\n    }\n\n    UserRole role;\n    User* user = authenticate_user(email, password, &role);\n\n    if (user != NULL) {\n        server_resp.status = 0;\n        server_resp.user_id = user->id;\n        strcpy(server_resp.message, \"Login bem-sucedido.\");\n        switch (role) {\n            case ROLE_ADMIN: strcpy(server_resp.data, \"ROLE_ADMIN\"); break;\n            case ROLE_PROFESSOR: strcpy(server_resp.data, \"ROLE_PROFESSOR\"); break;\n            case ROLE_STUDENT: strcpy(server_resp.data, \"ROLE_STUDENT\"); break;\n            default: strcpy(server_resp.data, \"UNKNOWN_ROLE\"); break;\n        }\n    } else {\n        strcpy(server_resp.message, \"Email ou senha incorretos.\");\n    }\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de adicionar professor\nServerResponse handle_admin_add_professor_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao adicionar professor.\");\n\n    char name[MAX_STR_LEN];\n    char email[MAX_EMAIL_LEN];\n    char password[MAX_PASSWORD_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        strncpy(name, token, MAX_STR_LEN - 1);\n        name[MAX_STR_LEN - 1] = '\\0';\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(email, token, MAX_EMAIL_LEN - 1);\n            email[MAX_EMAIL_LEN - 1] = '\\0';\n            token = strtok(NULL, \",\");\n            if (token != NULL) {\n                strncpy(password, token, MAX_PASSWORD_LEN - 1);\n                password[MAX_PASSWORD_LEN - 1] = '\\0';\n            } else {\n                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para adicionar professor: senha ausente.\");\n                return server_resp;\n            }\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para adicionar professor: email ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para adicionar professor: nome ausente.\");\n        return server_resp;\n    }\n\n    int result = add_professor(name, email, password, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de editar professor\nServerResponse handle_admin_edit_professor_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao editar professor.\");\n\n    int id;\n    char name[MAX_STR_LEN];\n    char email[MAX_EMAIL_LEN];\n    char password[MAX_PASSWORD_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(name, token, MAX_STR_LEN - 1);\n            name[MAX_STR_LEN - 1] = '\\0';\n            token = strtok(NULL, \",\");\n            if (token != NULL) {\n                strncpy(email, token, MAX_EMAIL_LEN - 1);\n                email[MAX_EMAIL_LEN - 1] = '\\0';\n                token = strtok(NULL, \",\");\n                if (token != NULL) {\n                    strncpy(password, token, MAX_PASSWORD_LEN - 1);\n                    password[MAX_PASSWORD_LEN - 1] = '\\0';\n                } else {\n                    snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para editar professor: senha ausente.\");\n                    return server_resp;\n                }\n            } else {\n                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para editar professor: email ausente.\");\n                return server_resp;\n            }\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para editar professor: nome ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para editar professor: ID ausente.\");\n        return server_resp;\n    }\n\n    int result = edit_professor(id, name, email, password, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de listar professores\nServerResponse handle_admin_list_professors_command() {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = 0; // Assume sucesso, a lista pode ser vazia\n    strcpy(server_resp.message, \"Lista de professores enviada.\");\n\n    list_professors(server_resp.data, MAX_DATA_LEN); // Preenche server_resp.data com a lista\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de remover professor\nServerResponse handle_admin_remove_professor_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao remover professor.\");\n\n    int id;\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        id = atoi(token);\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para remover professor: ID ausente.\");\n        return server_resp;\n    }\n    int result = remove_professor(id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de adicionar turma\nServerResponse handle_admin_add_class_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao adicionar turma.\");\n\n    char name[MAX_STR_LEN];\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        strncpy(name, token, MAX_STR_LEN - 1);\n        name[MAX_STR_LEN - 1] = '\\0';\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para adicionar turma: nome ausente.\");\n        return server_resp;\n    }\n    int result = add_class(name, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de listar turmas\nServerResponse handle_admin_list_classes_command() {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = 0; // Assume sucesso, a lista pode ser vazia\n    strcpy(server_resp.message, \"Lista de turmas enviada.\");\n\n    list_classes(server_resp.data, MAX_DATA_LEN);\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de editar turma\nServerResponse handle_admin_edit_class_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao editar turma.\");\n\n    int id;\n    char name[MAX_STR_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(name, token, MAX_STR_LEN - 1);\n            name[MAX_STR_LEN - 1] = '\\0';\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para editar turma: nome ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para editar turma: ID ausente.\");\n        return server_resp;\n    }\n    int result = edit_class(id, name, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de remover turma\nServerResponse handle_admin_remove_class_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao remover turma.\");\n\n    int id;\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        id = atoi(token);\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para remover turma: ID ausente.\");\n        return server_resp;\n    }\n    int result = remove_class(id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de adicionar aluno\nServerResponse handle_admin_add_student_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao adicionar aluno.\");\n\n    char name[MAX_STR_LEN];\n    char email[MAX_EMAIL_LEN];\n    char password[MAX_PASSWORD_LEN];\n    int class_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        strncpy(name, token, MAX_STR_LEN - 1);\n        name[MAX_STR_LEN - 1] = '\\0';\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(email, token, MAX_EMAIL_LEN - 1);\n            email[MAX_EMAIL_LEN - 1] = '\\0';\n            token = strtok(NULL, \",\");\n            if (token != NULL) {\n                strncpy(password, token, MAX_PASSWORD_LEN - 1);\n                password[MAX_PASSWORD_LEN - 1] = '\\0';\n                token = strtok(NULL, \",\");\n                if (token != NULL) {\n                    class_id = atoi(token);\n                } else {\n                    snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para adicionar aluno: ID da turma ausente.\");\n                    return server_resp;\n                }\n            } else {\n                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para adicionar aluno: senha ausente.\");\n                return server_resp;\n            }\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para adicionar aluno: email ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para adicionar aluno: nome ausente.\");\n        return server_resp;\n    }\n\n    int result = add_student(name, email, password, class_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de listar alunos\nServerResponse handle_admin_list_students_command() {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = 0; // Assume sucesso, a lista pode ser vazia\n    strcpy(server_resp.message, \"Lista de alunos enviada.\");\n\n    list_students(server_resp.data, MAX_DATA_LEN);\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de editar aluno\nServerResponse handle_admin_edit_student_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao editar aluno.\");\n\n    int id;\n    char name[MAX_STR_LEN];\n    char email[MAX_EMAIL_LEN];\n    char password[MAX_PASSWORD_LEN];\n    int class_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(name, token, MAX_STR_LEN - 1);\n            name[MAX_STR_LEN - 1] = '\\0';\n            token = strtok(NULL, \",\");\n            if (token != NULL) {\n                strncpy(email, token, MAX_EMAIL_LEN - 1);\n                email[MAX_EMAIL_LEN - 1] = '\\0';\n                token = strtok(NULL, \",\");\n                if (token != NULL) {\n                    strncpy(password, token, MAX_PASSWORD_LEN - 1);\n                    password[MAX_PASSWORD_LEN - 1] = '\\0';\n                    token = strtok(NULL, \",\");\n                    if (token != NULL) {\n                        class_id = atoi(token);\n                    } else {\n                        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para editar aluno: ID da turma ausente.\");\n                        return server_resp;\n                    }\n                } else {\n                    snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para editar aluno: senha ausente.\");\n                    return server_resp;\n                }\n            } else {\n                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para editar aluno: email ausente.\");\n                return server_resp;\n            }\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para editar aluno: nome ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para editar aluno: ID ausente.\");\n        return server_resp;\n    }\n\n    int result = edit_student(id, name, email, password, class_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de remover aluno\nServerResponse handle_admin_remove_student_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao remover aluno.\");\n\n    int id;\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        id = atoi(token);\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para remover aluno: ID ausente.\");\n        return server_resp;\n    }\n    int result = remove_student(id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de atribuir matéria ao professor (ADMIN)\nServerResponse handle_admin_assign_subject_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao atribuir matéria.\");\n\n    int professor_id;\n    int subject_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        professor_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            subject_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para atribuir matéria: ID da matéria ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para atribuir matéria: ID do professor ausente.\");\n        return server_resp;\n    }\n\n    int result = admin_assign_subject_to_professor(professor_id, subject_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de desatribuir matéria do professor (ADMIN)\nServerResponse handle_admin_unassign_subject_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao desatribuir matéria.\");\n\n    int professor_id;\n    int subject_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        professor_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            subject_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para desatribuir matéria: ID da matéria ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para desatribuir matéria: ID do professor ausente.\");\n        return server_resp;\n    }\n\n    int result = admin_unassign_subject_from_professor(professor_id, subject_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de atribuir turma ao professor (ADMIN)\nServerResponse handle_admin_assign_class_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao atribuir turma.\");\n\n    int professor_id;\n    int class_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        professor_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            class_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para atribuir turma: ID da turma ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para atribuir turma: ID do professor ausente.\");\n        return server_resp;\n    }\n\n    int result = admin_assign_class_to_professor(professor_id, class_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de desatribuir turma do professor (ADMIN)\nServerResponse handle_admin_unassign_class_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao desatribuir turma.\");\n\n    int professor_id;\n    int class_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        professor_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            class_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para desatribuir turma: ID da turma ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para desatribuir turma: ID do professor ausente.\");\n        return server_resp;\n    }\n\n    int result = admin_unassign_class_from_professor(professor_id, class_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de listar turmas atribuídas ao professor\nServerResponse handle_professor_list_assigned_classes_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = 0;\n    strcpy(server_resp.message, \"Lista de turmas atribuídas enviada.\");\n\n    int professor_id = client_msg.user_id;\n    list_professor_assigned_classes(professor_id, server_resp.data, MAX_DATA_LEN);\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de listar matérias atribuídas ao professor\nServerResponse handle_professor_list_assigned_subjects_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = 0;\n    strcpy(server_resp.message, \"Lista de matérias atribuídas enviada.\");\n\n    int professor_id = client_msg.user_id;\n    list_professor_assigned_subjects(professor_id, server_resp.data, MAX_DATA_LEN);\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de lançar nota\nServerResponse handle_professor_post_grade_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao lançar nota.\");\n\n    int professor_id = client_msg.user_id;\n    int student_id;\n    int subject_id;\n    float grade_value;\n    char description[MAX_STR_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        student_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            subject_id = atoi(token);\n            token = strtok(NULL, \",\");\n            if (token != NULL) {\n                grade_value = atof(token);\n                token = strtok(NULL, \",\");\n                if (token != NULL) {\n                    strncpy(description, token, MAX_STR_LEN - 1);\n                    description[MAX_STR_LEN - 1] = '\\0';\n                } else {\n                    snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para lançar nota: descrição ausente.\");\n                    return server_resp;\n                }\n            } else {\n                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para lançar nota: valor da nota ausente.\");\n                return server_resp;\n            }\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para lançar nota: ID da matéria ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para lançar nota: ID do aluno ausente.\");\n        return server_resp;\n    }\n    int result = post_grade(professor_id, student_id, subject_id, grade_value, description, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de registrar falta\nServerResponse handle_professor_register_absence_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao registrar falta.\");\n\n    int professor_id = client_msg.user_id;\n    int student_id;\n    int subject_id;\n    char date[MAX_STR_LEN];\n    char justification[MAX_STR_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        student_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            subject_id = atoi(token);\n            token = strtok(NULL, \",\");\n            if (token != NULL) {\n                strncpy(date, token, MAX_STR_LEN - 1);\n                date[MAX_STR_LEN - 1] = '\\0';\n                token = strtok(NULL, \",\");\n                if (token != NULL) {\n                    strncpy(justification, token, MAX_STR_LEN - 1);\n                    justification[MAX_STR_LEN - 1] = '\\0';\n                } else {\n                    justification[0] = '\\0'; // Justificativa pode ser opcional\n                }\n            } else {\n                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para registrar falta: data ausente.\");\n                return server_resp;\n            }\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para registrar falta: ID da matéria ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para registrar falta: ID do aluno ausente.\");\n        return server_resp;\n    }\n    int result = register_absence(professor_id, student_id, subject_id, date, justification, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\n// Nova função para lidar com o comando de visualizar notas/faltas\nServerResponse handle_professor_view_grades_absences_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao visualizar notas/faltas.\");\n\n    int professor_id = client_msg.user_id;\n    int student_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        student_id = atoi(token);\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para visualizar notas/faltas: ID do aluno ausente.\");\n        return server_resp;\n    }\n    view_student_grades_absences(professor_id, student_id, server_resp.data, MAX_DATA_LEN);\n    server_resp.status = 0;\n    strcpy(server_resp.message, \"Dados de notas e faltas do aluno enviados.\");\n    return server_resp;\n}\n\n// Função para processar comandos do cliente no servidor\nServerResponse process_client_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1; // Padrão de erro\n    strcpy(server_resp.message, \"Comando desconhecido ou não implementado.\");\n\n    switch (client_msg.command) {\n        case CMD_LOGIN: {\n            server_resp = handle_login_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_ADD_PROFESSOR: {\n            server_resp = handle_admin_add_professor_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_EDIT_PROFESSOR: {\n            server_resp = handle_admin_edit_professor_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_LIST_PROFESSORS: {\n            server_resp = handle_admin_list_professors_command();\n            break;\n        }\n        case CMD_ADMIN_REMOVE_PROFESSOR: {\n            server_resp = handle_admin_remove_professor_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_ADD_CLASS: {\n            server_resp = handle_admin_add_class_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_LIST_CLASSES: {\n            server_resp = handle_admin_list_classes_command();\n            break;\n        }\n        case CMD_ADMIN_EDIT_CLASS: {\n            server_resp = handle_admin_edit_class_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_REMOVE_CLASS: {\n            server_resp = handle_admin_remove_class_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_ADD_STUDENT: {\n            server_resp = handle_admin_add_student_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_LIST_STUDENTS: {\n            server_resp = handle_admin_list_students_command();\n            break;\n        }\n        case CMD_ADMIN_EDIT_STUDENT: {\n            server_resp = handle_admin_edit_student_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_REMOVE_STUDENT: {\n            server_resp = handle_admin_remove_student_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_ASSIGN_SUBJECT: {\n            server_resp = handle_admin_assign_subject_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_UNASSIGN_SUBJECT: {\n            server_resp = handle_admin_unassign_subject_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_ASSIGN_CLASS: {\n            server_resp = handle_admin_assign_class_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_UNASSIGN_CLASS: {\n            server_resp = handle_admin_unassign_class_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_ASSIGN_SUBJECT_TO_PROFESSOR: {\n            server_resp = handle_admin_assign_subject_to_professor_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_UNASSIGN_SUBJECT_FROM_PROFESSOR: {\n            server_resp = handle_admin_unassign_subject_from_professor_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_ASSIGN_CLASS_TO_PROFESSOR: {\n            server_resp = handle_admin_assign_class_to_professor_command(client_msg);\n            break;\n        }\n        case CMD_ADMIN_UNASSIGN_CLASS_FROM_PROFESSOR: {\n            server_resp = handle_admin_unassign_class_from_professor_command(client_msg);\n            break;\n        }\n        // --- Comandos de Professor ---\n        case CMD_PROFESSOR_LIST_ASSIGNED_CLASSES: {\n            server_resp = handle_professor_list_assigned_classes_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_LIST_ASSIGNED_SUBJECTS: {\n            server_resp = handle_professor_list_assigned_subjects_command(client_msg);\n            break;\n        }\n        // --- Comandos de Professor - Notas e Faltas ---\n        case CMD_PROFESSOR_POST_GRADE: {\n            server_resp = handle_professor_post_grade_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_REGISTER_ABSENCE: {\n            server_resp = handle_professor_register_absence_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_VIEW_GRADES_ABSENCES: {\n            server_resp = handle_professor_view_grades_absences_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_CREATE_SUBJECT_MODULE: {\n            server_resp = handle_professor_create_subject_module_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_LIST_SUBJECT_MODULES: {\n            server_resp = handle_professor_list_subject_modules_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_EDIT_MODULE: {\n            server_resp = handle_professor_edit_module_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_REMOVE_MODULE: {\n            server_resp = handle_professor_remove_module_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_ADD_LESSON_TO_MODULE: {\n            server_resp = handle_professor_add_lesson_to_module_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_EDIT_LESSON: {\n            server_resp = handle_professor_edit_lesson_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_REMOVE_LESSON: {\n            server_resp = handle_professor_remove_lesson_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_LIST_MODULE_LESSONS: {\n            server_resp = handle_professor_list_module_lessons_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_CREATE_MODULE_QUIZ: {\n            server_resp = handle_professor_create_module_quiz_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_EDIT_QUIZ: {\n            server_resp = handle_professor_edit_quiz_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_REMOVE_QUIZ: {\n            server_resp = handle_professor_remove_quiz_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_ADD_QUESTION_TO_QUIZ: {\n            server_resp = handle_professor_add_question_to_quiz_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_EDIT_QUESTION: {\n            server_resp = handle_professor_edit_question_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_REMOVE_QUESTION: {\n            server_resp = handle_professor_remove_question_command(client_msg);\n            break;\n        }\n        case CMD_PROFESSOR_LIST_MODULE_QUIZZES: {\n            server_resp = handle_professor_list_module_quizzes_command(client_msg);\n            break;\n        }\n\n        // --- Comandos de Aluno ---\n        case CMD_STUDENT_ENROLL_SUBJECT: {\n            server_resp.status = -1;\n            strcpy(server_resp.message, \"Funcionalidade de matrícula/desmatrícula de matéria movida para o Administrador.\");\n            break;\n        }\n        case CMD_STUDENT_UNENROLL_SUBJECT: {\n            server_resp.status = -1;\n            strcpy(server_resp.message, \"Funcionalidade de matrícula/desmatrícula de matéria movida para o Administrador.\");\n            break;\n        }\n        case CMD_STUDENT_LIST_ENROLLED_SUBJECTS: {\n            server_resp.status = -1;\n            strcpy(server_resp.message, \"Funcionalidade de listar matérias matriculadas movida para o Administrador.\");\n            break;\n        }\n        case CMD_STUDENT_LIST_MODULES_IN_SUBJECT: {\n            server_resp = handle_student_list_modules_in_subject_command(client_msg);\n            break;\n        }\n        case CMD_STUDENT_VIEW_LESSONS_IN_MODULE: {\n            server_resp = handle_student_view_lessons_in_module_command(client_msg);\n            break;\n        }\n        case CMD_STUDENT_VIEW_QUIZZES_IN_MODULE: {\n            server_resp = handle_student_view_quizzes_in_module_command(client_msg);\n            break;\n        }\n        case CMD_STUDENT_TAKE_QUIZ: {\n            server_resp = handle_student_take_quiz_command(client_msg);\n            break;\n        }\n        case CMD_STUDENT_REQUEST_QUIZ_QUESTIONS: {\n            server_resp = handle_student_request_quiz_questions_command(client_msg);\n            break;\n        }\n        case CMD_STUDENT_VIEW_GRADES: {\n            server_resp = handle_student_view_grades_command(client_msg);\n            break;\n        }\n        case CMD_STUDENT_VIEW_ABSENCES: {\n            server_resp = handle_student_view_absences_command(client_msg);\n            break;\n        }\n\n        default:\n            // Mensagem padrão de erro já definida\n            break;\n    }\n\n    return server_resp;\n}\n\n// Funções de tratamento de comandos de Aluno\n\n// As funções handle_student_enroll_subject_command, handle_student_unenroll_subject_command e handle_student_list_enrolled_subjects_command\n// foram movidas para o módulo de administração e, portanto, não são mais necessárias aqui.\n// Os comandos correspondentes em process_client_command agora retornam uma mensagem informativa.\n\nServerResponse handle_student_list_modules_in_subject_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao listar módulos da matéria.\");\n\n    int student_id;\n    int subject_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        student_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            subject_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para listar módulos da matéria: ID da matéria ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para listar módulos da matéria: ID do aluno ausente.\");\n        return server_resp;\n    }\n\n    student_list_modules_in_subject(student_id, subject_id, server_resp.data, MAX_DATA_LEN);\n    server_resp.status = 0;\n    strcpy(server_resp.message, \"Módulos da matéria listados com sucesso!\");\n    return server_resp;\n}\n\nServerResponse handle_student_view_lessons_in_module_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao visualizar aulas do módulo.\");\n\n    int student_id;\n    int module_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        student_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            module_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para visualizar aulas do módulo: ID do módulo ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para visualizar aulas do módulo: ID do aluno ausente.\");\n        return server_resp;\n    }\n\n    student_view_lessons_in_module(student_id, module_id, server_resp.data, MAX_DATA_LEN);\n    server_resp.status = 0;\n    strcpy(server_resp.message, \"Aulas do módulo listadas com sucesso!\");\n    return server_resp;\n}\n\nServerResponse handle_student_view_quizzes_in_module_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao visualizar questionários do módulo.\");\n\n    int student_id;\n    int module_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        student_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            module_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para visualizar questionários do módulo: ID do módulo ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para visualizar questionários do módulo: ID do aluno ausente.\");\n        return server_resp;\n    }\n\n    student_view_quizzes_in_module(student_id, module_id, server_resp.data, MAX_DATA_LEN);\n    server_resp.status = 0;\n    strcpy(server_resp.message, \"Questionários do módulo listados com sucesso!\");\n    return server_resp;\n}\n\nServerResponse handle_student_take_quiz_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao fazer questionário.\");\n\n    int student_id;\n    int quiz_id;\n    // int answers[MAX_QUESTIONS_PER_QUIZ]; // As respostas serão tratadas via string\n    // int num_answers = 0; // Não é mais relevante aqui\n\n    char temp_data[MAX_DATA_LEN];\n    strncpy(temp_data, client_msg.data, MAX_DATA_LEN - 1);\n    temp_data[MAX_DATA_LEN - 1] = '\\0';\n\n    char* token = strtok(temp_data, \",\");\n    if (token != NULL) {\n        quiz_id = atoi(token); // O primeiro token é o quiz_id\n        \n        token = strtok(NULL, \"\"); // O resto da string são as respostas no formato Q_ID:Answer_Option,...\n        char* answers_str = token;\n\n        if (answers_str == NULL || strlen(answers_str) == 0) {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para fazer questionário: respostas ausentes.\");\n            return server_resp;\n        }\n\n        student_id = client_msg.user_id; // student_id vem de client_msg.user_id\n        \n        // Chamar nova função para processar as respostas\n        int result = student_submit_quiz_answers(student_id, quiz_id, answers_str, server_resp.message, MAX_MESSAGE_LEN);\n        server_resp.status = (result == 0) ? 0 : -1;\n\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido para fazer questionário: ID do questionário ausente.\");\n        return server_resp;\n    }\n\n    return server_resp;\n}\n\nServerResponse handle_student_view_grades_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao visualizar notas.\");\n\n    int student_id = client_msg.user_id;\n\n    student_view_grades(student_id, server_resp.data, MAX_DATA_LEN);\n    server_resp.status = 0;\n    strcpy(server_resp.message, \"Notas listadas com sucesso!\");\n    return server_resp;\n}\n\nServerResponse handle_student_view_absences_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao visualizar faltas.\");\n\n    int student_id = client_msg.user_id;\n\n    student_view_absences(student_id, server_resp.data, MAX_DATA_LEN);\n    server_resp.status = 0;\n    strcpy(server_resp.message, \"Faltas listadas com sucesso!\");\n    return server_resp;\n}\n\nServerResponse handle_admin_assign_subject_to_professor_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao atribuir matéria ao professor.\");\n\n    int professor_id;\n    int subject_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        professor_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            subject_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID da matéria ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do professor ausente.\");\n        return server_resp;\n    }\n\n    int result = admin_assign_subject_to_professor(professor_id, subject_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_admin_unassign_subject_from_professor_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao desatribuir matéria do professor.\");\n\n    int professor_id;\n    int subject_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        professor_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            subject_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID da matéria ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do professor ausente.\");\n        return server_resp;\n    }\n\n    int result = admin_unassign_subject_from_professor(professor_id, subject_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_admin_assign_class_to_professor_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao atribuir turma ao professor.\");\n\n    int professor_id;\n    int class_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        professor_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            class_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID da turma ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do professor ausente.\");\n        return server_resp;\n    }\n\n    int result = admin_assign_class_to_professor(professor_id, class_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_admin_unassign_class_from_professor_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao desatribuir turma do professor.\");\n\n    int professor_id;\n    int class_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        professor_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            class_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID da turma ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do professor ausente.\");\n        return server_resp;\n    }\n\n    int result = admin_unassign_class_from_professor(professor_id, class_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_create_subject_module_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao criar módulo em matéria.\");\n\n    int professor_id = client_msg.user_id;\n    int subject_id;\n    char module_name[MAX_STR_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        subject_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(module_name, token, MAX_STR_LEN - 1);\n            module_name[MAX_STR_LEN - 1] = '\\0';\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: nome do módulo ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID da matéria ausente.\");\n        return server_resp;\n    }\n\n    int result = create_subject_module(professor_id, subject_id, module_name, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_list_subject_modules_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao listar módulos da matéria.\");\n\n    int professor_id = client_msg.user_id;\n    int subject_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        subject_id = atoi(token);\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID da matéria ausente.\");\n        return server_resp;\n    }\n\n    // A função list_subject_modules preenche server_resp.data diretamente\n    list_subject_modules(professor_id, subject_id, server_resp.data, MAX_DATA_LEN);\n    server_resp.status = 0; // Assume sucesso, a lista pode ser vazia\n    strcpy(server_resp.message, \"Módulos da matéria enviados.\");\n    return server_resp;\n}\n\nServerResponse handle_professor_edit_module_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao editar módulo.\");\n\n    int professor_id = client_msg.user_id;\n    int module_id;\n    char new_name[MAX_STR_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        module_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(new_name, token, MAX_STR_LEN - 1);\n            new_name[MAX_STR_LEN - 1] = '\\0';\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: novo nome do módulo ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do módulo ausente.\");\n        return server_resp;\n    }\n\n    int result = edit_module(professor_id, module_id, new_name, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_remove_module_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao remover módulo.\");\n\n    int professor_id = client_msg.user_id;\n    int module_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        module_id = atoi(token);\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do módulo ausente.\");\n        return server_resp;\n    }\n\n    int result = remove_module(professor_id, module_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_add_lesson_to_module_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao adicionar aula ao módulo.\");\n\n    int professor_id = client_msg.user_id;\n    int module_id;\n    char lesson_title[MAX_STR_LEN];\n    char lesson_content[MAX_DATA_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        module_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(lesson_title, token, MAX_STR_LEN - 1);\n            lesson_title[MAX_STR_LEN - 1] = '\\0';\n            token = strtok(NULL, \",\");\n            if (token != NULL) {\n                strncpy(lesson_content, token, MAX_DATA_LEN - 1);\n                lesson_content[MAX_DATA_LEN - 1] = '\\0';\n            } else {\n                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: conteúdo da aula ausente.\");\n                return server_resp;\n            }\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: título da aula ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do módulo ausente.\");\n        return server_resp;\n    }\n\n    int result = add_lesson_to_module(professor_id, module_id, lesson_title, lesson_content, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_edit_lesson_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao editar aula.\");\n\n    int professor_id = client_msg.user_id;\n    int lesson_id;\n    char new_title[MAX_STR_LEN];\n    char new_content[MAX_DATA_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        lesson_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(new_title, token, MAX_STR_LEN - 1);\n            new_title[MAX_STR_LEN - 1] = '\\0';\n            token = strtok(NULL, \",\");\n            if (token != NULL) {\n                strncpy(new_content, token, MAX_DATA_LEN - 1);\n                new_content[MAX_DATA_LEN - 1] = '\\0';\n            } else {\n                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: novo conteúdo da aula ausente.\");\n                return server_resp;\n            }\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: novo título da aula ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID da aula ausente.\");\n        return server_resp;\n    }\n\n    int result = edit_lesson(professor_id, lesson_id, new_title, new_content, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_remove_lesson_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao remover aula.\");\n\n    int professor_id = client_msg.user_id;\n    int lesson_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        lesson_id = atoi(token);\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID da aula ausente.\");\n        return server_resp;\n    }\n\n    int result = remove_lesson(professor_id, lesson_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_list_module_lessons_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao listar aulas do módulo.\");\n\n    int professor_id = client_msg.user_id;\n    int module_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        module_id = atoi(token);\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do módulo ausente.\");\n        return server_resp;\n    }\n\n    list_module_lessons(professor_id, module_id, server_resp.data, MAX_DATA_LEN);\n    server_resp.status = 0;\n    strcpy(server_resp.message, \"Aulas do módulo enviadas.\");\n    return server_resp;\n}\n\nServerResponse handle_professor_create_module_quiz_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao criar questionário em módulo.\");\n\n    int professor_id = client_msg.user_id;\n    int module_id;\n    char quiz_title[MAX_STR_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        module_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(quiz_title, token, MAX_STR_LEN - 1);\n            quiz_title[MAX_STR_LEN - 1] = '\\0';\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: título do questionário ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do módulo ausente.\");\n        return server_resp;\n    }\n\n    int result = create_module_quiz(professor_id, module_id, quiz_title, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_edit_quiz_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao editar questionário.\");\n\n    int professor_id = client_msg.user_id;\n    int quiz_id;\n    char new_title[MAX_STR_LEN];\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        quiz_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(new_title, token, MAX_STR_LEN - 1);\n            new_title[MAX_STR_LEN - 1] = '\\0';\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: novo título do questionário ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do questionário ausente.\");\n        return server_resp;\n    }\n\n    int result = edit_quiz(professor_id, quiz_id, new_title, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_remove_quiz_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao remover questionário.\");\n\n    int professor_id = client_msg.user_id;\n    int quiz_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        quiz_id = atoi(token);\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do questionário ausente.\");\n        return server_resp;\n    }\n\n    int result = remove_quiz(professor_id, quiz_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_add_question_to_quiz_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao adicionar pergunta ao questionário.\");\n\n    int professor_id = client_msg.user_id;\n    int quiz_id;\n    char question_text[MAX_STR_LEN];\n    char option1[MAX_STR_LEN], option2[MAX_STR_LEN], option3[MAX_STR_LEN], option4[MAX_STR_LEN];\n    int correct_option;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        quiz_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            strncpy(question_text, token, MAX_STR_LEN - 1);\n            question_text[MAX_STR_LEN - 1] = '\\0';\n            token = strtok(NULL, \",\");\n            if (token != NULL) {\n                strncpy(option1, token, MAX_STR_LEN - 1);\n                option1[MAX_STR_LEN - 1] = '\\0';\n                token = strtok(NULL, \",\");\n                if (token != NULL) {\n                    strncpy(option2, token, MAX_STR_LEN - 1);\n                    option2[MAX_STR_LEN - 1] = '\\0';\n                    token = strtok(NULL, \",\");\n                    if (token != NULL) {\n                        strncpy(option3, token, MAX_STR_LEN - 1);\n                        option3[MAX_STR_LEN - 1] = '\\0';\n                        token = strtok(NULL, \",\");\n                        if (token != NULL) {\n                            strncpy(option4, token, MAX_STR_LEN - 1);\n                            option4[MAX_STR_LEN - 1] = '\\0';\n                            token = strtok(NULL, \",\");\n                            if (token != NULL) {\n                                correct_option = atoi(token);\n                            } else {\n                                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: opção correta ausente.\");\n                                return server_resp;\n                            }\n                        } else {\n                            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: opção 4 ausente.\");\n                            return server_resp;\n                        }\n                    } else {\n                        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: opção 3 ausente.\");\n                        return server_resp;\n                    }\n                } else {\n                    snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: opção 2 ausente.\");\n                    return server_resp;\n                }\n            } else {\n                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: opção 1 ausente.\");\n                return server_resp;\n            }\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: texto da pergunta ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do questionário ausente.\");\n        return server_resp;\n    }\n\n    int result = add_question_to_quiz(professor_id, quiz_id, question_text, option1, option2, option3, option4, correct_option, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_edit_question_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao editar pergunta do questionário.\");\n\n    int professor_id = client_msg.user_id;\n    int quiz_id;\n    int question_id;\n    char new_text[MAX_STR_LEN];\n    char new_option1[MAX_STR_LEN], new_option2[MAX_STR_LEN], new_option3[MAX_STR_LEN], new_option4[MAX_STR_LEN];\n    int new_correct_option;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        quiz_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            question_id = atoi(token);\n            token = strtok(NULL, \",\");\n            if (token != NULL) {\n                strncpy(new_text, token, MAX_STR_LEN - 1);\n                new_text[MAX_STR_LEN - 1] = '\\0';\n                token = strtok(NULL, \",\");\n                if (token != NULL) {\n                    strncpy(new_option1, token, MAX_STR_LEN - 1);\n                    new_option1[MAX_STR_LEN - 1] = '\\0';\n                    token = strtok(NULL, \",\");\n                    if (token != NULL) {\n                        strncpy(new_option2, token, MAX_STR_LEN - 1);\n                        new_option2[MAX_STR_LEN - 1] = '\\0';\n                        token = strtok(NULL, \",\");\n                        if (token != NULL) {\n                            strncpy(new_option3, token, MAX_STR_LEN - 1);\n                            new_option3[MAX_STR_LEN - 1] = '\\0';\n                            token = strtok(NULL, \",\");\n                            if (token != NULL) {\n                                strncpy(new_option4, token, MAX_STR_LEN - 1);\n                                new_option4[MAX_STR_LEN - 1] = '\\0';\n                                token = strtok(NULL, \",\");\n                                if (token != NULL) {\n                                    new_correct_option = atoi(token);\n                                } else {\n                                    snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: nova opção correta ausente.\");\n                                    return server_resp;\n                                }\n                            } else {\n                                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: nova opção 4 ausente.\");\n                                return server_resp;\n                            }\n                        } else {\n                            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: nova opção 3 ausente.\");\n                            return server_resp;\n                        }\n                    } else {\n                        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: nova opção 2 ausente.\");\n                        return server_resp;\n                    }\n                } else {\n                    snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: nova opção 1 ausente.\");\n                    return server_resp;\n                }\n            } else {\n                snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: novo texto da pergunta ausente.\");\n                return server_resp;\n            }\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID da pergunta ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do questionário ausente.\");\n        return server_resp;\n    }\n\n    int result = edit_question(professor_id, quiz_id, question_id, new_text, new_option1, new_option2, new_option3, new_option4, new_correct_option, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_remove_question_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao remover pergunta do questionário.\");\n\n    int professor_id = client_msg.user_id;\n    int quiz_id;\n    int question_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        quiz_id = atoi(token);\n        token = strtok(NULL, \",\");\n        if (token != NULL) {\n            question_id = atoi(token);\n        } else {\n            snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID da pergunta ausente.\");\n            return server_resp;\n        }\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do questionário ausente.\");\n        return server_resp;\n    }\n\n    int result = remove_question(professor_id, quiz_id, question_id, server_resp.message, MAX_MESSAGE_LEN);\n    server_resp.status = (result == 0) ? 0 : -1;\n    return server_resp;\n}\n\nServerResponse handle_professor_list_module_quizzes_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao listar questionários do módulo.\");\n\n    int professor_id = client_msg.user_id;\n    int module_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        module_id = atoi(token);\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do módulo ausente.\");\n        return server_resp;\n    }\n\n    list_module_quizzes(professor_id, module_id, server_resp.data, MAX_DATA_LEN);\n    server_resp.status = 0;\n    strcpy(server_resp.message, \"Questionários do módulo enviados.\");\n    return server_resp;\n}\n\nServerResponse handle_student_request_quiz_questions_command(ClientMessage client_msg) {\n    ServerResponse server_resp;\n    memset(&server_resp, 0, sizeof(ServerResponse));\n    server_resp.status = -1;\n    strcpy(server_resp.message, \"Erro ao solicitar perguntas do questionário.\");\n\n    int student_id = client_msg.user_id;\n    int quiz_id;\n\n    char* token = strtok(client_msg.data, \",\");\n    if (token != NULL) {\n        quiz_id = atoi(token);\n    } else {\n        snprintf(server_resp.message, MAX_MESSAGE_LEN, \"Formato de dados inválido: ID do questionário ausente.\");\n        return server_resp;\n    }\n\n    // Aqui, vamos chamar uma nova função em student.c para obter as perguntas\n    // e formatá-las no server_resp.data\n    char questions_data[MAX_DATA_LEN];\n    int result = student_get_quiz_questions(student_id, quiz_id, questions_data, MAX_DATA_LEN, server_resp.message, MAX_MESSAGE_LEN);\n\n    if (result == 0) {\n        server_resp.status = 0;\n        strcpy(server_resp.message, \"Perguntas do questionário enviadas.\");\n        strncpy(server_resp.data, questions_data, MAX_DATA_LEN - 1);\n        server_resp.data[MAX_DATA_LEN - 1] = '\\0';\n    } else {\n        // server_resp.message já foi preenchido por student_get_quiz_questions em caso de erro\n    }\n\n    return server_resp;\n}","size_bytes":70077},"src/client.c":{"content":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#pragma comment(lib, \"ws2_32.lib\")\n#else\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#endif\n\n#include \"client.h\"\n#include \"protocol.h\" // Necessário para ServerResponse e CommandType\n#include \"common_utils.h\" // Para funções de utilidade de entrada de usuário e menus\n#include \"models.h\" // Necessário para UserRole\n\n// Protótipos das funções de manipulação do professor\nvoid handle_professor_actions(int professor_id, int client_socket);\nvoid handle_professor_grades_absences_menu(int professor_id, int client_socket);\nvoid handle_professor_modules_lessons_menu(int professor_id, int client_socket);\nvoid handle_professor_quizzes_menu(int professor_id, int client_socket);\n\n// Função para enviar uma mensagem ao servidor e receber a resposta\nServerResponse send_command_to_server(int client_socket, CommandType command, int user_id, const char* data) {\n    ClientMessage client_msg;\n    ServerResponse server_resp;\n\n    client_msg.command = command;\n    client_msg.user_id = user_id;\n    strncpy(client_msg.data, data, sizeof(client_msg.data) - 1);\n    client_msg.data[sizeof(client_msg.data) - 1] = '\\0';\n\n    send(client_socket, (char*)&client_msg, sizeof(ClientMessage), 0);\n    recv(client_socket, (char*)&server_resp, sizeof(ServerResponse), 0);\n\n    return server_resp;\n}\n\nvoid start_client(const char* server_ip, int port) {\n#ifdef _WIN32\n    WSADATA wsa;\n    printf(\"Inicializando Winsock para cliente...\\n\");\n    if (WSAStartup(MAKEWORD(2,2),&wsa) != 0) {\n        printf(\"Erro. Código de erro: %d\\n\", WSAGetLastError());\n        return;\n    }\n    printf(\"Winsock inicializado para cliente.\\n\");\n#endif\n\n    int client_socket;\n    struct sockaddr_in server_addr;\n\n    // Cria o socket do cliente\n    client_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (client_socket == -1) {\n        perror(\"Erro ao criar socket do cliente\");\n#ifdef _WIN32\n        WSACleanup();\n#endif\n        return;\n    }\n\n    // Configura o endereço do servidor\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Endereço IP inválido/não suportado\");\n#ifdef _WIN32\n        closesocket(client_socket);\n        WSACleanup();\n#else\n        close(client_socket);\n#endif\n        return;\n    }\n\n    // Conecta ao servidor\n    if (connect(client_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        perror(\"Erro ao conectar ao servidor\");\n#ifdef _WIN32\n        closesocket(client_socket);\n        WSACleanup();\n#else\n        close(client_socket);\n#endif\n        return;\n    }\n\n    printf(\"Conectado ao servidor %s:%d\\n\", server_ip, port);\n\n    // Lógica do cliente (menu de login, admin, professor, aluno)\n    int choice;\n    char email[MAX_EMAIL_LEN];\n    char password[MAX_PASSWORD_LEN];\n    int logged_in_user_id = 0;\n    UserRole current_user_role = (UserRole)CMD_UNKNOWN; // Usar CMD_UNKNOWN como um papel inicial inválido\n\n    do {\n        display_main_menu(); // Menu principal para login/saída\n        choice = get_int_input(\"Escolha uma opção: \");\n\n        switch (choice) {\n            case 1: { // Login\n                get_string_input(\"Email: \", email, MAX_EMAIL_LEN);\n                get_string_input(\"Senha: \", password, MAX_PASSWORD_LEN);\n                char login_data[MAX_EMAIL_LEN + MAX_PASSWORD_LEN + 2]; // email,senha\n                sprintf(login_data, \"%s,%s\", email, password);\n\n                ServerResponse resp = send_command_to_server(client_socket, CMD_LOGIN, 0, login_data);\n\n                if (resp.status == 0) {\n                    printf(\"Login bem-sucedido! Bem-vindo(a)!\\n\");\n                    logged_in_user_id = resp.user_id; // logged_in_user_id agora é utilizado\n                    // Converter resp.data (string) para UserRole\n                    if (strcmp(resp.data, \"ROLE_ADMIN\") == 0) {\n                        current_user_role = ROLE_ADMIN;\n                    } else if (strcmp(resp.data, \"ROLE_PROFESSOR\") == 0) {\n                        current_user_role = ROLE_PROFESSOR;\n                    } else if (strcmp(resp.data, \"ROLE_STUDENT\") == 0) {\n                        current_user_role = ROLE_STUDENT;\n                    }\n\n                    // Entrar no menu de acordo com o papel\n                    switch (current_user_role) {\n                        case ROLE_ADMIN: {\n                            int admin_choice;\n                            do {\n                                display_admin_main_menu();\n                                admin_choice = get_int_input(\"Escolha uma opção: \");\n\n                                switch (admin_choice) {\n                                    case 1: { // Gerenciar Professores\n                                        int prof_choice;\n                                        do {\n                                            display_admin_professor_menu();\n                                            prof_choice = get_int_input(\"Escolha uma opção: \");\n                                            switch (prof_choice) {\n                                                case 1: { // Adicionar Professor\n                                                    char name[MAX_STR_LEN];\n                                                    char email[MAX_EMAIL_LEN];\n                                                    char password[MAX_PASSWORD_LEN];\n                                                    get_string_input(\"Nome do Professor: \", name, MAX_STR_LEN);\n                                                    get_string_input(\"Email do Professor: \", email, MAX_EMAIL_LEN);\n                                                    get_string_input(\"Senha do Professor: \", password, MAX_PASSWORD_LEN);\n                                                    char data_to_send[MAX_DATA_LEN];\n                                                    snprintf(data_to_send, MAX_DATA_LEN, \"%s,%s,%s\", name, email, password);\n                                                    ServerResponse add_prof_resp = send_command_to_server(client_socket, CMD_ADMIN_ADD_PROFESSOR, logged_in_user_id, data_to_send);\n                                                    if (add_prof_resp.status == 0) {\n                                                        printf(\"Sucesso: %s\\n\", add_prof_resp.message);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", add_prof_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 2: { // Listar Professores\n                                                    ServerResponse list_prof_resp = send_command_to_server(client_socket, CMD_ADMIN_LIST_PROFESSORS, logged_in_user_id, \"\");\n                                                    if (list_prof_resp.status == 0) {\n                                                        printf(\"\\n--- LISTA DE PROFESSORES ---\\n%s-----------------------------\\n\", list_prof_resp.data);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", list_prof_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 3: { // Editar Professor\n                                                    int id = get_int_input(\"ID do Professor a ser editado: \");\n                                                    char name[MAX_STR_LEN];\n                                                    char email[MAX_EMAIL_LEN];\n                                                    char password[MAX_PASSWORD_LEN];\n                                                    get_string_input(\"Novo Nome: \", name, MAX_STR_LEN);\n                                                    get_string_input(\"Novo Email: \", email, MAX_EMAIL_LEN);\n                                                    get_string_input(\"Nova Senha: \", password, MAX_PASSWORD_LEN);\n                                                    char data_to_send[MAX_DATA_LEN];\n                                                    snprintf(data_to_send, MAX_DATA_LEN, \"%d,%s,%s,%s\", id, name, email, password);\n                                                    ServerResponse edit_prof_resp = send_command_to_server(client_socket, CMD_ADMIN_EDIT_PROFESSOR, logged_in_user_id, data_to_send);\n                                                    if (edit_prof_resp.status == 0) {\n                                                        printf(\"Sucesso: %s\\n\", edit_prof_resp.message);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", edit_prof_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 4: { // Remover Professor\n                                                    int id = get_int_input(\"ID do Professor a ser removido: \");\n                                                    char data_to_send[MAX_DATA_LEN];\n                                                    snprintf(data_to_send, MAX_DATA_LEN, \"%d\", id);\n                                                    ServerResponse remove_prof_resp = send_command_to_server(client_socket, CMD_ADMIN_REMOVE_PROFESSOR, logged_in_user_id, data_to_send);\n                                                    if (remove_prof_resp.status == 0) {\n                                                        printf(\"Sucesso: %s\\n\", remove_prof_resp.message);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", remove_prof_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 0: break;\n                                                default: printf(\"Opção inválida. Tente novamente.\\n\"); break;\n                                            }\n                                        } while (prof_choice != 0);\n                                        break;\n                                    }\n                                    case 2: { // Gerenciar Turmas\n                                        int class_choice;\n                                        do {\n                                            display_admin_class_menu();\n                                            class_choice = get_int_input(\"Escolha uma opção: \");\n                                            switch (class_choice) {\n                                                case 1: { // Adicionar Turma\n                                                    char name[MAX_STR_LEN];\n                                                    get_string_input(\"Nome da Turma: \", name, MAX_STR_LEN);\n                                                    char data_to_send[MAX_DATA_LEN];\n                                                    snprintf(data_to_send, MAX_DATA_LEN, \"%s\", name);\n                                                    ServerResponse add_class_resp = send_command_to_server(client_socket, CMD_ADMIN_ADD_CLASS, logged_in_user_id, data_to_send);\n                                                    if (add_class_resp.status == 0) {\n                                                        printf(\"Sucesso: %s\\n\", add_class_resp.message);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", add_class_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 2: { // Listar Turmas\n                                                    ServerResponse list_class_resp = send_command_to_server(client_socket, CMD_ADMIN_LIST_CLASSES, logged_in_user_id, \"\");\n                                                    if (list_class_resp.status == 0) {\n                                                        printf(\"\\n--- LISTA DE TURMAS ---\\n%s-------------------------\\n\", list_class_resp.data);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", list_class_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 3: { // Editar Turma\n                                                    int id = get_int_input(\"ID da Turma a ser editada: \");\n                                                    char name[MAX_STR_LEN];\n                                                    get_string_input(\"Novo Nome: \", name, MAX_STR_LEN);\n                                                    char data_to_send[MAX_DATA_LEN];\n                                                    snprintf(data_to_send, MAX_DATA_LEN, \"%d,%s\", id, name);\n                                                    ServerResponse edit_class_resp = send_command_to_server(client_socket, CMD_ADMIN_EDIT_CLASS, logged_in_user_id, data_to_send);\n                                                    if (edit_class_resp.status == 0) {\n                                                        printf(\"Sucesso: %s\\n\", edit_class_resp.message);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", edit_class_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 4: { // Remover Turma\n                                                    int id = get_int_input(\"ID da Turma a ser removida: \");\n                                                    char data_to_send[MAX_DATA_LEN];\n                                                    snprintf(data_to_send, MAX_DATA_LEN, \"%d\", id);\n                                                    ServerResponse remove_class_resp = send_command_to_server(client_socket, CMD_ADMIN_REMOVE_CLASS, logged_in_user_id, data_to_send);\n                                                    if (remove_class_resp.status == 0) {\n                                                        printf(\"Sucesso: %s\\n\", remove_class_resp.message);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", remove_class_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 0: break;\n                                                default: printf(\"Opção inválida. Tente novamente.\\n\"); break;\n                                            }\n                                        } while (class_choice != 0);\n                                        break;\n                                    }\n                                    case 3: { // Gerenciar Alunos\n                                        int student_choice;\n                                        do {\n                                            display_admin_student_menu();\n                                            student_choice = get_int_input(\"Escolha uma opção: \");\n                                            switch (student_choice) {\n                                                case 1: { // Adicionar Aluno\n                                                    char name[MAX_STR_LEN];\n                                                    char email[MAX_EMAIL_LEN];\n                                                    char password[MAX_PASSWORD_LEN];\n                                                    int class_id;\n                                                    get_string_input(\"Nome do Aluno: \", name, MAX_STR_LEN);\n                                                    get_string_input(\"Email do Aluno: \", email, MAX_EMAIL_LEN);\n                                                    get_string_input(\"Senha do Aluno: \", password, MAX_PASSWORD_LEN);\n                                                    class_id = get_int_input(\"ID da Turma: \");\n                                                    char data_to_send[MAX_DATA_LEN];\n                                                    snprintf(data_to_send, MAX_DATA_LEN, \"%s,%s,%s,%d\", name, email, password, class_id);\n                                                    ServerResponse add_student_resp = send_command_to_server(client_socket, CMD_ADMIN_ADD_STUDENT, logged_in_user_id, data_to_send);\n                                                    if (add_student_resp.status == 0) {\n                                                        printf(\"Sucesso: %s\\n\", add_student_resp.message);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", add_student_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 2: { // Listar Alunos\n                                                    ServerResponse list_student_resp = send_command_to_server(client_socket, CMD_ADMIN_LIST_STUDENTS, logged_in_user_id, \"\");\n                                                    if (list_student_resp.status == 0) {\n                                                        printf(\"\\n--- LISTA DE ALUNOS ---\\n%s---------------------------\\n\", list_student_resp.data);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", list_student_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 3: { // Editar Aluno\n                                                    int id = get_int_input(\"ID do Aluno a ser editado: \");\n                                                    char name[MAX_STR_LEN];\n                                                    char email[MAX_EMAIL_LEN];\n                                                    char password[MAX_PASSWORD_LEN];\n                                                    int new_class_id;\n                                                    get_string_input(\"Novo Nome: \", name, MAX_STR_LEN);\n                                                    get_string_input(\"Novo Email: \", email, MAX_EMAIL_LEN);\n                                                    get_string_input(\"Nova Senha: \", password, MAX_PASSWORD_LEN);\n                                                    new_class_id = get_int_input(\"Novo ID da Turma (0 para manter): \");\n                                                    char data_to_send[MAX_DATA_LEN];\n                                                    snprintf(data_to_send, MAX_DATA_LEN, \"%d,%s,%s,%s,%d\", id, name, email, password, new_class_id);\n                                                    ServerResponse edit_student_resp = send_command_to_server(client_socket, CMD_ADMIN_EDIT_STUDENT, logged_in_user_id, data_to_send);\n                                                    if (edit_student_resp.status == 0) {\n                                                        printf(\"Sucesso: %s\\n\", edit_student_resp.message);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", edit_student_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 4: { // Remover Aluno\n                                                    int id = get_int_input(\"ID do Aluno a ser removido: \");\n                                                    char data_to_send[MAX_DATA_LEN];\n                                                    snprintf(data_to_send, MAX_DATA_LEN, \"%d\", id);\n                                                    ServerResponse remove_student_resp = send_command_to_server(client_socket, CMD_ADMIN_REMOVE_STUDENT, logged_in_user_id, data_to_send);\n                                                    if (remove_student_resp.status == 0) {\n                                                        printf(\"Sucesso: %s\\n\", remove_student_resp.message);\n                                                    } else {\n                                                        printf(\"Erro: %s\\n\", remove_student_resp.message);\n                                                    }\n                                                    break;\n                                                }\n                                                case 0: break;\n                                                default: printf(\"Opção inválida. Tente novamente.\\n\"); break;\n                                            }\n                                        } while (student_choice != 0);\n                                        break;\n                                    }\n                                    case 4: { // Gerenciar Atribuições Professor-Matéria/Turma\n                                        handle_admin_professor_subject_class_assignment_menu(logged_in_user_id, client_socket);\n                                        break;\n                                    }\n                                    case 0: break;\n                                    default: printf(\"Opção inválida. Tente novamente.\\n\"); break;\n                                }\n                            } while (admin_choice != 0);\n                            break;\n                        }\n                        case ROLE_PROFESSOR:\n                            printf(\"Login bem-sucedido! Bem-vindo(a)! Logado como Professor.\\n\");\n                            handle_professor_actions(logged_in_user_id, client_socket);\n                            break;\n                        case ROLE_STUDENT:\n                            printf(\"Login bem-sucedido! Bem-vindo(a)! Logado como Aluno.\\n\");\n                            handle_student_actions(logged_in_user_id, client_socket);\n                            break;\n                        default:\n                            printf(\"Erro: Papel de usuário desconhecido.\\n\");\n                            break;\n                    }\n\n                } else {\n                    printf(\"Erro de login: %s\\n\", resp.message);\n                }\n                break;\n            }\n            case 0: // Sair\n                printf(\"Desconectando do servidor. Até mais!\\n\");\n                // Enviar comando de logout ao servidor (opcional)\n                break;\n            default:\n                printf(\"Opção inválida. Tente novamente.\\n\");\n        }\n    } while (choice != 0);\n\n#ifdef _WIN32\n    closesocket(client_socket);\n    WSACleanup();\n#else\n    close(client_socket);\n#endif\n}\n\n// main para o cliente (temporário, pode ser movido para um arquivo cliente_main.c dedicado)\n/*\nint main() {\n    start_client(\"127.0.0.1\", 8080);\n    return 0;\n}\n*/\n\nvoid handle_professor_actions(int professor_id, int client_socket) {\n    int choice;\n    int running = 1;\n\n    while (running) {\n        display_professor_main_menu();\n        choice = get_int_input(\"\");\n        clear_input_buffer();\n\n        switch (choice) {\n            case 1: // Gerenciar Matérias e Turmas Atribuídas\n                printf(\"\\nFuncionalidade movida para o menu do Administrador. Por favor, entre em contato com o administrador para gerenciar atribuições.\\n\");\n                break;\n            case 2: // Gerenciar Notas e Faltas de Alunos\n                handle_professor_grades_absences_menu(professor_id, client_socket);\n                break;\n            case 3: // Gerenciar Módulos e Aulas\n                handle_professor_modules_lessons_menu(professor_id, client_socket);\n                break;\n            case 4: // Gerenciar Questionários\n                handle_professor_quizzes_menu(professor_id, client_socket);\n                break;\n            case 0: // Logout\n                running = 0;\n                printf(\"Voltando ao Menu Principal.\\n\");\n                break;\n            default:\n                printf(\"Opção inválida. Tente novamente.\\n\");\n                break;\n        }\n    }\n}\n\nvoid handle_professor_grades_absences_menu(int professor_id, int client_socket) {\n    int choice;\n    int running = 1;\n    char input_buffer[MAX_DATA_LEN];\n    ServerResponse server_resp;\n\n    while (running) {\n        display_professor_grades_absences_menu();\n        choice = get_int_input(\"\");\n        clear_input_buffer();\n\n        switch (choice) {\n            case 1: { // Lançar Nota\n                int student_id, subject_id;\n                float grade_value;\n                char description[MAX_STR_LEN];\n                printf(\"ID do Aluno: \");\n                student_id = get_int_input(\"\");\n                printf(\"ID da Matéria: \");\n                subject_id = get_int_input(\"\");\n                printf(\"Valor da Nota: \");\n                scanf(\"%f\", &grade_value);\n                clear_input_buffer();\n                printf(\"Descrição (ex: 'Prova 1'): \");\n                get_string_input(\"Descrição (ex: 'Prova 1'): \", description, MAX_STR_LEN);\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d,%f,%s\", student_id, subject_id, grade_value, description);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_POST_GRADE, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 2: { // Registrar Falta\n                int student_id, subject_id;\n                char date[MAX_STR_LEN];\n                char justification[MAX_STR_LEN];\n                printf(\"ID do Aluno: \");\n                student_id = get_int_input(\"\");\n                printf(\"ID da Matéria: \");\n                subject_id = get_int_input(\"\");\n                printf(\"Data (DD/MM/AAAA): \");\n                get_string_input(\"Data (DD/MM/AAAA): \", date, MAX_STR_LEN);\n                printf(\"Justificativa (opcional): \");\n                get_string_input(\"Justificativa (opcional): \", justification, MAX_STR_LEN);\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d,%s,%s\", student_id, subject_id, date, justification);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_REGISTER_ABSENCE, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 3: { // Visualizar Notas e Faltas de Aluno\n                int student_id;\n                printf(\"ID do Aluno para visualizar: \");\n                student_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d\", student_id);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_VIEW_GRADES_ABSENCES, professor_id, input_buffer);\n                printf(\"\\n--- NOTAS E FALTAS DO ALUNO ---\\n\");\n                printf(\"%s\\n\", server_resp.data);\n                printf(\"----------------------------------\\n\");\n                break;\n            }\n            case 0: // Voltar\n                running = 0;\n                break;\n            default:\n                printf(\"Opção inválida. Tente novamente.\\n\");\n                break;\n        }\n    }\n}\n\nvoid handle_professor_modules_lessons_menu(int professor_id, int client_socket) {\n    int choice;\n    int running = 1;\n    char input_buffer[MAX_DATA_LEN];\n    ServerResponse server_resp;\n\n    while (running) {\n        display_professor_modules_lessons_menu();\n        choice = get_int_input(\"\");\n        clear_input_buffer();\n\n        switch (choice) {\n            case 1: { // Criar Módulo em Matéria\n                int subject_id;\n                char module_name[MAX_STR_LEN];\n                printf(\"ID da Matéria para criar módulo: \");\n                subject_id = get_int_input(\"\");\n                printf(\"Nome do Módulo: \");\n                get_string_input(\"Nome do Módulo: \", module_name, MAX_STR_LEN);\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%s\", subject_id, module_name);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_CREATE_SUBJECT_MODULE, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 2: { // Listar Módulos de Matéria\n                int subject_id;\n                printf(\"ID da Matéria para listar módulos: \");\n                subject_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d\", subject_id);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_LIST_SUBJECT_MODULES, professor_id, input_buffer);\n                printf(\"\\n--- MÓDULOS DA MATÉRIA ---\\n\");\n                printf(\"%s\\n\", server_resp.data);\n                printf(\"--------------------------\\n\");\n                break;\n            }\n            case 3: { // Editar Módulo\n                int module_id;\n                char new_name[MAX_STR_LEN];\n                printf(\"ID do Módulo a editar: \");\n                module_id = get_int_input(\"\");\n                printf(\"Novo Nome do Módulo: \");\n                get_string_input(\"Novo Nome do Módulo: \", new_name, MAX_STR_LEN);\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%s\", module_id, new_name);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_EDIT_MODULE, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 4: { // Remover Módulo\n                int module_id;\n                printf(\"ID do Módulo a remover: \");\n                module_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d\", module_id);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_REMOVE_MODULE, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 5: { // Adicionar Aula a Módulo\n                int module_id;\n                char lesson_title[MAX_STR_LEN];\n                char youtube_link[MAX_STR_LEN];\n                printf(\"ID do Módulo para adicionar aula: \");\n                module_id = get_int_input(\"\");\n                printf(\"Título da Aula: \");\n                get_string_input(\"Título da Aula: \", lesson_title, MAX_STR_LEN);\n                printf(\"Link do YouTube: \");\n                get_string_input(\"Link do YouTube: \", youtube_link, MAX_STR_LEN);\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%s,%s\", module_id, lesson_title, youtube_link);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_ADD_LESSON_TO_MODULE, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 6: { // Editar Aula\n                int lesson_id;\n                char new_title[MAX_STR_LEN];\n                char new_youtube_link[MAX_STR_LEN];\n                printf(\"ID da Aula a editar: \");\n                lesson_id = get_int_input(\"\");\n                printf(\"Novo Título da Aula: \");\n                get_string_input(\"Novo Título da Aula: \", new_title, MAX_STR_LEN);\n                printf(\"Novo Link do YouTube: \");\n                get_string_input(\"Novo Link do YouTube: \", new_youtube_link, MAX_STR_LEN);\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%s,%s\", lesson_id, new_title, new_youtube_link);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_EDIT_LESSON, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 7: { // Remover Aula\n                int lesson_id;\n                printf(\"ID da Aula a remover: \");\n                lesson_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d\", lesson_id);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_REMOVE_LESSON, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 8: { // Listar Aulas de Módulo\n                int module_id;\n                printf(\"ID do Módulo para listar aulas: \");\n                module_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d\", module_id);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_LIST_MODULE_LESSONS, professor_id, input_buffer);\n                printf(\"\\n--- AULAS DO MÓDULO ---\\n\");\n                printf(\"%s\\n\", server_resp.data);\n                printf(\"-------------------------\\n\");\n                break;\n            }\n            case 0: // Voltar\n                running = 0;\n                break;\n            default:\n                printf(\"Opção inválida. Tente novamente.\\n\");\n                break;\n        }\n    }\n}\n\nvoid handle_professor_quizzes_menu(int professor_id, int client_socket) {\n    int choice;\n    int running = 1;\n    char input_buffer[MAX_DATA_LEN];\n    ServerResponse server_resp;\n\n    while (running) {\n        display_professor_quizzes_menu();\n        choice = get_int_input(\"\");\n        clear_input_buffer();\n\n        switch (choice) {\n            case 1: { // Criar Questionário em Módulo\n                int module_id;\n                char quiz_title[MAX_STR_LEN];\n                printf(\"ID do Módulo para criar questionário: \");\n                module_id = get_int_input(\"\");\n                printf(\"Título do Questionário: \");\n                get_string_input(\"Título do Questionário: \", quiz_title, MAX_STR_LEN);\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%s\", module_id, quiz_title);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_CREATE_MODULE_QUIZ, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 2: { // Editar Questionário\n                int quiz_id;\n                char new_title[MAX_STR_LEN];\n                printf(\"ID do Questionário a editar: \");\n                quiz_id = get_int_input(\"\");\n                printf(\"Novo Título do Questionário: \");\n                get_string_input(\"Novo Título do Questionário: \", new_title, MAX_STR_LEN);\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%s\", quiz_id, new_title);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_EDIT_QUIZ, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 3: { // Remover Questionário\n                int quiz_id;\n                printf(\"ID do Questionário a remover: \");\n                quiz_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d\", quiz_id);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_REMOVE_QUIZ, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 4: { // Adicionar Pergunta a Questionário\n                int quiz_id, correct_option;\n                char question_text[MAX_STR_LEN];\n                char option1[MAX_STR_LEN], option2[MAX_STR_LEN], option3[MAX_STR_LEN], option4[MAX_STR_LEN];\n                printf(\"ID do Questionário para adicionar pergunta: \");\n                quiz_id = get_int_input(\"\");\n                printf(\"Texto da Pergunta: \");\n                get_string_input(\"Texto da Pergunta: \", question_text, MAX_STR_LEN);\n                printf(\"Opção 1: \");\n                get_string_input(\"Opção 1: \", option1, MAX_STR_LEN);\n                printf(\"Opção 2: \");\n                get_string_input(\"Opção 2: \", option2, MAX_STR_LEN);\n                printf(\"Opção 3: \");\n                get_string_input(\"Opção 3: \", option3, MAX_STR_LEN);\n                printf(\"Opção 4: \");\n                get_string_input(\"Opção 4: \", option4, MAX_STR_LEN);\n                printf(\"Opção Correta (1-4): \");\n                correct_option = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%s,%s,%s,%s,%s,%d\", \n                         quiz_id, question_text, option1, option2, option3, option4, correct_option);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_ADD_QUESTION_TO_QUIZ, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 5: { // Editar Pergunta de Questionário\n                int quiz_id, question_id, new_correct_option;\n                char new_text[MAX_STR_LEN];\n                char new_option1[MAX_STR_LEN], new_option2[MAX_STR_LEN], new_option3[MAX_STR_LEN], new_option4[MAX_STR_LEN];\n                printf(\"ID do Questionário da pergunta: \");\n                quiz_id = get_int_input(\"\");\n                printf(\"ID da Pergunta a editar: \");\n                question_id = get_int_input(\"\");\n                printf(\"Novo Texto da Pergunta: \");\n                get_string_input(\"Novo Texto da Pergunta: \", new_text, MAX_STR_LEN);\n                printf(\"Nova Opção 1: \");\n                get_string_input(\"Nova Opção 1: \", new_option1, MAX_STR_LEN);\n                printf(\"Nova Opção 2: \");\n                get_string_input(\"Nova Opção 2: \", new_option2, MAX_STR_LEN);\n                printf(\"Nova Opção 3: \");\n                get_string_input(\"Nova Opção 3: \", new_option3, MAX_STR_LEN);\n                printf(\"Nova Opção 4: \");\n                get_string_input(\"Nova Opção 4: \", new_option4, MAX_STR_LEN);\n                printf(\"Nova Opção Correta (1-4): \");\n                new_correct_option = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d,%s,%s,%s,%s,%s,%d\", \n                         quiz_id, question_id, new_text, new_option1, new_option2, new_option3, new_option4, new_correct_option);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_EDIT_QUESTION, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 6: { // Remover Pergunta de Questionário\n                int quiz_id, question_id;\n                printf(\"ID do Questionário da pergunta: \");\n                quiz_id = get_int_input(\"\");\n                printf(\"ID da Pergunta a remover: \");\n                question_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d\", quiz_id, question_id);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_REMOVE_QUESTION, professor_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 7: { // Listar Questionários de Módulo\n                int module_id;\n                printf(\"ID do Módulo para listar questionários: \");\n                module_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d\", module_id);\n                server_resp = send_command_to_server(client_socket, CMD_PROFESSOR_LIST_MODULE_QUIZZES, professor_id, input_buffer);\n                printf(\"\\n--- QUESTIONÁRIOS DO MÓDULO ---\\n\");\n                printf(\"%s\\n\", server_resp.data);\n                printf(\"----------------------------------\\n\");\n                break;\n            }\n            case 0: // Voltar\n                running = 0;\n                break;\n            default:\n                printf(\"Opção inválida. Tente novamente.\\n\");\n                break;\n        }\n    }\n}\n\n// Funções de menu para o aluno\nvoid display_student_main_menu() {\n    printf(\"\\n--- MENU DO ALUNO ---\\n\");\n    printf(\"1. Gerenciar Matérias (Matricular/Desmatricular/Listar)\\n\");\n    printf(\"2. Visualizar Conteúdo (Módulos, Aulas, Questionários)\\n\");\n    printf(\"3. Fazer Questionário\\n\");\n    printf(\"4. Visualizar Notas e Faltas\\n\");\n    printf(\"0. Logout\\n\");\n    printf(\"---------------------\\n\");\n}\n\nvoid display_student_subject_menu() {\n    printf(\"\\n--- GERENCIAR MATÉRIAS ---\\n\");\n    printf(\"1. Matricular-se em Matéria\\n\");\n    printf(\"2. Desmatricular-se de Matéria\\n\");\n    printf(\"3. Listar Matérias Matriculadas\\n\");\n    printf(\"0. Voltar\\n\");\n    printf(\"--------------------------\\n\");\n}\n\nvoid display_student_module_menu() {\n    printf(\"\\n--- VISUALIZAR CONTEÚDO ---\\n\");\n    printf(\"1. Listar Módulos de uma Matéria\\n\");\n    printf(\"2. Visualizar Aulas de um Módulo\\n\");\n    printf(\"3. Visualizar Questionários de um Módulo\\n\");\n    printf(\"0. Voltar\\n\");\n    printf(\"---------------------------\\n\");\n}\n\nvoid display_student_quiz_menu() {\n    printf(\"\\n--- FAZER QUESTIONÁRIO ---\\n\");\n    printf(\"1. Listar Questionários de um Módulo\\n\");\n    printf(\"2. Iniciar Questionário\\n\");\n    printf(\"0. Voltar\\n\");\n    printf(\"---------------------------\\n\");\n}\n\nvoid handle_student_actions(int student_id, int client_socket) {\n    int choice;\n    int running = 1;\n    char input_buffer[MAX_DATA_LEN];\n    ServerResponse server_resp;\n\n    while (running) {\n        display_student_main_menu();\n        choice = get_int_input(\"Escolha uma opção: \");\n        clear_input_buffer();\n\n        switch (choice) {\n            case 1: { // Gerenciar Matérias\n                int subject_menu_choice;\n                do {\n                    display_student_subject_menu();\n                    subject_menu_choice = get_int_input(\"Escolha uma opção: \");\n                    clear_input_buffer();\n                    switch (subject_menu_choice) {\n                        case 1: { // Matricular-se em Matéria\n                            int subject_id = get_int_input(\"ID da Matéria para matricular-se: \");\n                            snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d\", student_id, subject_id);\n                            server_resp = send_command_to_server(client_socket, CMD_STUDENT_ENROLL_SUBJECT, student_id, input_buffer);\n                            printf(\"Resposta: %s\\n\", server_resp.message);\n                            break;\n                        }\n                        case 2: { // Desmatricular-se de Matéria\n                            int subject_id = get_int_input(\"ID da Matéria para desmatricular-se: \");\n                            snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d\", student_id, subject_id);\n                            server_resp = send_command_to_server(client_socket, CMD_STUDENT_UNENROLL_SUBJECT, student_id, input_buffer);\n                            printf(\"Resposta: %s\\n\", server_resp.message);\n                            break;\n                        }\n                        case 3: { // Listar Matérias Matriculadas\n                            server_resp = send_command_to_server(client_socket, CMD_STUDENT_LIST_ENROLLED_SUBJECTS, student_id, \"\");\n                            printf(\"\\n--- SUAS MATÉRIAS MATRICULADAS ---\\n\");\n                            printf(\"%s\\n\", server_resp.data);\n                            printf(\"------------------------------------\\n\");\n                            break;\n                        }\n                        case 0: break;\n                        default: printf(\"Opção inválida. Tente novamente.\\n\"); break;\n                    }\n                } while (subject_menu_choice != 0);\n                break;\n            }\n            case 2: { // Visualizar Conteúdo (Módulos, Aulas, Questionários)\n                int module_view_choice;\n                do {\n                    display_student_module_menu();\n                    module_view_choice = get_int_input(\"Escolha uma opção: \");\n                    clear_input_buffer();\n                    switch (module_view_choice) {\n                        case 1: { // Listar Módulos de uma Matéria\n                            int subject_id = get_int_input(\"ID da Matéria para listar módulos: \");\n                            snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d\", student_id, subject_id);\n                            server_resp = send_command_to_server(client_socket, CMD_STUDENT_LIST_MODULES_IN_SUBJECT, student_id, input_buffer);\n                            printf(\"\\n--- MÓDULOS DA MATÉRIA ---\\n\");\n                            printf(\"%s\\n\", server_resp.data);\n                            printf(\"--------------------------\\n\");\n                            break;\n                        }\n                        case 2: { // Visualizar Aulas de um Módulo\n                            int module_id = get_int_input(\"ID do Módulo para visualizar aulas: \");\n                            snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d\", student_id, module_id);\n                            server_resp = send_command_to_server(client_socket, CMD_STUDENT_VIEW_LESSONS_IN_MODULE, student_id, input_buffer);\n                            printf(\"\\n--- AULAS DO MÓDULO ---\\n\");\n                            printf(\"%s\\n\", server_resp.data);\n                            printf(\"-------------------------\\n\");\n                            break;\n                        }\n                        case 3: { // Visualizar Questionários de um Módulo\n                            int module_id = get_int_input(\"ID do Módulo para visualizar questionários: \");\n                            snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d\", student_id, module_id);\n                            server_resp = send_command_to_server(client_socket, CMD_STUDENT_VIEW_QUIZZES_IN_MODULE, student_id, input_buffer);\n                            printf(\"\\n--- QUESTIONÁRIOS DO MÓDULO ---\\n\");\n                            printf(\"%s\\n\", server_resp.data);\n                            printf(\"----------------------------------\\n\");\n                            break;\n                        }\n                        case 0: break;\n                        default: printf(\"Opção inválida. Tente novamente.\\n\"); break;\n                    }\n                } while (module_view_choice != 0);\n                break;\n            }\n            case 3: { // Fazer Questionário\n                int quiz_menu_choice;\n                do {\n                    display_student_quiz_menu();\n                    quiz_menu_choice = get_int_input(\"Escolha uma opção: \");\n                    clear_input_buffer();\n                    switch (quiz_menu_choice) {\n                        case 1: { // Listar Questionários de um Módulo\n                            int module_id = get_int_input(\"ID do Módulo para listar questionários: \");\n                            snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d\", student_id, module_id);\n                            server_resp = send_command_to_server(client_socket, CMD_STUDENT_VIEW_QUIZZES_IN_MODULE, student_id, input_buffer);\n                            printf(\"\\n--- QUESTIONÁRIOS DO MÓDULO ---\\n\");\n                            printf(\"%s\\n\", server_resp.data);\n                            printf(\"----------------------------------\\n\");\n                            break;\n                        }\n                        case 2: { // Iniciar Questionário\n                            int quiz_id = get_int_input(\"ID do Questionário para fazer: \");\n                            \n                            // 1. Solicitar perguntas do questionário ao servidor\n                            snprintf(input_buffer, MAX_DATA_LEN, \"%d\", quiz_id);\n                            server_resp = send_command_to_server(client_socket, CMD_STUDENT_REQUEST_QUIZ_QUESTIONS, student_id, input_buffer);\n\n                            if (server_resp.status != 0) {\n                                printf(\"Erro ao obter perguntas do questionário: %s\\n\", server_resp.message);\n                                break;\n                            }\n                            \n                            if (strlen(server_resp.data) == 0) {\n                                printf(\"Nenhuma pergunta encontrada para o questionário %d.\\n\", quiz_id);\n                                break;\n                            }\n\n                            // 2. Analisar as perguntas e coletar respostas\n                            char temp_data[MAX_DATA_LEN];\n                            strncpy(temp_data, server_resp.data, MAX_DATA_LEN - 1);\n                            temp_data[MAX_DATA_LEN - 1] = '\\0';\n\n                            char* line = strtok(temp_data, \"\\n\");\n                            if (line == NULL) {\n                                printf(\"Formato de perguntas inválido.\\n\");\n                                break;\n                            }\n                            int num_questions_from_server = atoi(line); // Primeira linha é o número de questões\n                            \n                            if (num_questions_from_server <= 0) {\n                                printf(\"Nenhuma pergunta válida para o questionário %d.\\n\", quiz_id);\n                                break;\n                            }\n\n                            char answers_buffer[MAX_DATA_LEN] = \"\"; // Buffer para armazenar as respostas do aluno\n                            char answer_item[50]; // Para cada par Q_ID:Answer\n                            int current_question_idx = 0;\n\n                            line = strtok(NULL, \"\\n\"); // Pular para a primeira pergunta\n                            while (line != NULL && current_question_idx < num_questions_from_server) {\n                                char q_text[MAX_STR_LEN], opt1[MAX_STR_LEN], opt2[MAX_STR_LEN], opt3[MAX_STR_LEN], opt4[MAX_STR_LEN];\n                                int q_id;\n                                int len_text, len_opt1, len_opt2, len_opt3, len_opt4;\n                                int chosen_option;\n                                char* current_pos = line;\n\n                                // Parse o ID da pergunta\n                                sscanf(current_pos, \"%d|\", &q_id);\n                                current_pos = strchr(current_pos, '|') + 1; // Move para após o primeiro '|'\n\n                                // Parse o comprimento do texto da pergunta e o texto\n                                sscanf(current_pos, \"%d|\", &len_text);\n                                current_pos = strchr(current_pos, '|') + 1;\n                                strncpy(q_text, current_pos, len_text);\n                                q_text[len_text] = '\\0';\n                                current_pos += len_text + 1; // Move para após o texto e o próximo '|'\n\n                                // Parse o comprimento e o texto da opção 1\n                                sscanf(current_pos, \"%d|\", &len_opt1);\n                                current_pos = strchr(current_pos, '|') + 1;\n                                strncpy(opt1, current_pos, len_opt1);\n                                opt1[len_opt1] = '\\0';\n                                current_pos += len_opt1 + 1;\n\n                                // Parse o comprimento e o texto da opção 2\n                                sscanf(current_pos, \"%d|\", &len_opt2);\n                                current_pos = strchr(current_pos, '|') + 1;\n                                strncpy(opt2, current_pos, len_opt2);\n                                opt2[len_opt2] = '\\0';\n                                current_pos += len_opt2 + 1;\n\n                                // Parse o comprimento e o texto da opção 3\n                                sscanf(current_pos, \"%d|\", &len_opt3);\n                                current_pos = strchr(current_pos, '|') + 1;\n                                strncpy(opt3, current_pos, len_opt3);\n                                opt3[len_opt3] = '\\0';\n                                current_pos += len_opt3 + 1;\n\n                                // Parse o comprimento e o texto da opção 4\n                                sscanf(current_pos, \"%d|\", &len_opt4);\n                                current_pos = strchr(current_pos, '|') + 1;\n                                strncpy(opt4, current_pos, len_opt4);\n                                opt4[len_opt4] = '\\0';\n                                // current_pos += len_opt4 + 1; // Não é necessário mover para o próximo '|' pois é o final da linha\n                                \n                                printf(\"\\nPergunta %d (ID: %d): %s\\n\", current_question_idx + 1, q_id, q_text);\n                                printf(\"1. %s\\n\", opt1);\n                                printf(\"2. %s\\n\", opt2);\n                                printf(\"3. %s\\n\", opt3);\n                                printf(\"4. %s\\n\", opt4);\n                                \n                                do {\n                                    chosen_option = get_int_input(\"Sua resposta (1-4): \");\n                                    clear_input_buffer();\n                                    if (chosen_option < 1 || chosen_option > 4) {\n                                        printf(\"Opção inválida. Escolha entre 1 e 4.\\n\");\n                                    }\n                                } while (chosen_option < 1 || chosen_option > 4);\n\n                                // Formatar a resposta e adicionar ao buffer de respostas\n                                if (strlen(answers_buffer) > 0) {\n                                    strcat(answers_buffer, \",\");\n                                }\n                                snprintf(answer_item, sizeof(answer_item), \"%d:%d\", q_id, chosen_option);\n                                strcat(answers_buffer, answer_item);\n\n                                current_question_idx++;\n                                line = strtok(NULL, \"\\n\"); // Próxima pergunta\n                            }\n                            \n                            // 3. Enviar as respostas do aluno ao servidor\n                            // O input_buffer conterá \"quiz_id,Q_ID:Answer_Option,Q_ID:Answer_Option,...\"\n                            snprintf(input_buffer, MAX_DATA_LEN, \"%d,%s\", quiz_id, answers_buffer);\n                            server_resp = send_command_to_server(client_socket, CMD_STUDENT_TAKE_QUIZ, student_id, input_buffer);\n                            printf(\"Resposta: %s\\n\", server_resp.message);\n                            break;\n                        }\n                        case 0: break;\n                        default: printf(\"Opção inválida. Tente novamente.\\n\"); break;\n                    }\n                } while (quiz_menu_choice != 0);\n                break;\n            }\n            case 4: { // Visualizar Notas e Faltas\n                server_resp = send_command_to_server(client_socket, CMD_STUDENT_VIEW_GRADES, student_id, \"\");\n                printf(\"\\n--- SUAS NOTAS ---\\n\");\n                printf(\"%s\\n\", server_resp.data);\n                printf(\"------------------\\n\");\n\n                server_resp = send_command_to_server(client_socket, CMD_STUDENT_VIEW_ABSENCES, student_id, \"\");\n                printf(\"\\n--- SUAS FALTAS ---\\n\");\n                printf(\"%s\\n\", server_resp.data);\n                printf(\"-------------------\\n\");\n                break;\n            }\n            case 0: // Logout\n                running = 0;\n                printf(\"Voltando ao Menu Principal.\\n\");\n                break;\n            default:\n                printf(\"Opção inválida. Tente novamente.\\n\");\n                break;\n        }\n    }\n}\n\n// Novo: Lógica para o Menu de Gerenciamento de Matérias e Turmas do Administrador\nvoid handle_admin_professor_subject_class_assignment_menu(int admin_id, int client_socket) {\n    int choice;\n    int running = 1;\n    char input_buffer[MAX_DATA_LEN];\n    ServerResponse server_resp;\n\n    while (running) {\n        display_admin_professor_subject_class_assignment_menu();\n        choice = get_int_input(\"\");\n        clear_input_buffer();\n\n        switch (choice) {\n            case 1: { // Atribuir Matéria a Professor\n                int professor_id, subject_id;\n                printf(\"ID do Professor: \");\n                professor_id = get_int_input(\"\");\n                printf(\"ID da Matéria a atribuir: \");\n                subject_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d\", professor_id, subject_id);\n                server_resp = send_command_to_server(client_socket, CMD_ADMIN_ASSIGN_SUBJECT_TO_PROFESSOR, admin_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 2: { // Desatribuir Matéria de Professor\n                int professor_id, subject_id;\n                printf(\"ID do Professor: \");\n                professor_id = get_int_input(\"\");\n                printf(\"ID da Matéria a desatribuir: \");\n                subject_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d\", professor_id, subject_id);\n                server_resp = send_command_to_server(client_socket, CMD_ADMIN_UNASSIGN_SUBJECT_FROM_PROFESSOR, admin_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 3: { // Atribuir Turma a Professor\n                int professor_id, class_id;\n                printf(\"ID do Professor: \");\n                professor_id = get_int_input(\"\");\n                printf(\"ID da Turma a atribuir: \");\n                class_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d\", professor_id, class_id);\n                server_resp = send_command_to_server(client_socket, CMD_ADMIN_ASSIGN_CLASS_TO_PROFESSOR, admin_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 4: { // Desatribuir Turma de Professor\n                int professor_id, class_id;\n                printf(\"ID do Professor: \");\n                professor_id = get_int_input(\"\");\n                printf(\"ID da Turma a desatribuir: \");\n                class_id = get_int_input(\"\");\n                snprintf(input_buffer, MAX_DATA_LEN, \"%d,%d\", professor_id, class_id);\n                server_resp = send_command_to_server(client_socket, CMD_ADMIN_UNASSIGN_CLASS_FROM_PROFESSOR, admin_id, input_buffer);\n                printf(\"Resposta: %s\\n\", server_resp.message);\n                break;\n            }\n            case 0: // Voltar\n                running = 0;\n                break;\n            default:\n                printf(\"Opção inválida. Tente novamente.\\n\");\n                break;\n        }\n    }\n}\n","size_bytes":60044},"src/storage/storage.c":{"content":"#include \"storage/storage.h\"\n#include \"models.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nSystemData global_data; // Inicializa a variável global\n\nint save_data(const char* filename) {\n    FILE* file = fopen(filename, \"wb\");\n    if (file == NULL) {\n        perror(\"Erro ao abrir arquivo para salvar\");\n        return -1;\n    }\n    fwrite(&global_data, sizeof(SystemData), 1, file);\n    fclose(file);\n    printf(\"Dados salvos com sucesso em %s\\n\", filename);\n    return 0;\n}\n\nvoid load_data(const char* filename) {\n    FILE* file = fopen(filename, \"rb\");\n    if (file == NULL) {\n        perror(\"Erro ao abrir arquivo para carregar. Criando novos dados.\\n\");\n        // Inicializa global_data com valores padrão se o arquivo não existe\n        memset(&global_data, 0, sizeof(SystemData));\n        // Adicionar um administrador padrão se não houver um\n        if (global_data.num_admins == 0) {\n            global_data.admins[0].id = 1;\n            strcpy(global_data.admins[0].name, \"Admin Master\");\n            strcpy(global_data.admins[0].email, \"admin@admin.com\");\n            strcpy(global_data.admins[0].password, \"admin123\");\n            global_data.num_admins = 1;\n        }\n\n        return;\n    }\n    fread(&global_data, sizeof(SystemData), 1, file);\n    fclose(file);\n    printf(\"Dados carregados com sucesso de %s\\n\", filename);\n\n    // Garante que haja pelo menos um admin se o arquivo estava vazio ou corrompido sem admins\n    if (global_data.num_admins == 0) {\n        global_data.admins[0].id = 1;\n        strcpy(global_data.admins[0].name, \"Admin Master\");\n        strcpy(global_data.admins[0].email, \"admin@admin.com\");\n        strcpy(global_data.admins[0].password, \"admin123\");\n        global_data.num_admins = 1;\n    }\n}\n","size_bytes":1762},"src/server.c":{"content":"#include <stdio.h>\n#include <stdlib.h>\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#pragma comment(lib, \"ws2_32.lib\")\n#else\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#endif\n#include \"models.h\"\n#include \"storage/storage.h\"\n#include \"server_logic/server_logic.h\"\n#include \"server.h\"\n\n#define MAX_CLIENTS 5\n\n// Função para lidar com um cliente individual\nvoid handle_client(int client_socket) {\n    ClientMessage client_msg;\n    ssize_t bytes_received;\n\n    printf(\"Cliente conectado (socket %d).\\n\", client_socket);\n\n    // Loop para receber e responder mensagens do cliente\n    while ((bytes_received = recv(client_socket, (char*)&client_msg, sizeof(ClientMessage), 0)) > 0) {\n        printf(\"Mensagem recebida do cliente (socket %d): Comando %d, User ID %d, Data: %s\\n\", \n               client_socket, client_msg.command, client_msg.user_id, client_msg.data);\n\n        ServerResponse server_resp = process_client_command(client_msg);\n\n        send(client_socket, (char*)&server_resp, sizeof(ServerResponse), 0);\n        printf(\"Resposta enviada ao cliente (socket %d): Status %d, Mensagem: %s\\n\", \n               client_socket, server_resp.status, server_resp.message);\n    }\n\n    if (bytes_received == 0) {\n        printf(\"Cliente desconectado (socket %d).\\n\", client_socket);\n    } else if (bytes_received == -1) {\n        perror(\"Erro ao receber dados do cliente\");\n    }\n\n#ifdef _WIN32\n    closesocket(client_socket);\n#else\n    close(client_socket);\n#endif\n}\n\nvoid start_server(int port) {\n#ifdef _WIN32\n    WSADATA wsa;\n    printf(\"Inicializando Winsock...\\n\");\n    if (WSAStartup(MAKEWORD(2,2),&wsa) != 0) {\n        printf(\"Erro. Código de erro: %d\\n\", WSAGetLastError());\n        return;\n    }\n    printf(\"Winsock inicializado.\\n\");\n#endif\n\n    int server_socket, client_socket;\n    struct sockaddr_in server_addr, client_addr;\n    socklen_t client_len = sizeof(client_addr);\n\n    // Carrega dados do sistema (apenas uma vez no servidor)\n    load_data(\"system_data.dat\");\n\n    // Cria o socket do servidor\n    server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket == -1) {\n        perror(\"Erro ao criar socket do servidor\");\n#ifdef _WIN32\n        WSACleanup();\n#endif\n        return;\n    }\n\n    // Configura o endereço do servidor\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY; // Escuta em todas as interfaces\n    server_addr.sin_port = htons(port);\n\n    // Bind do socket ao endereço\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        perror(\"Erro ao fazer bind do socket\");\n#ifdef _WIN32\n        closesocket(server_socket);\n        WSACleanup();\n#endif\n        return;\n    }\n\n    // Começa a escutar por conexões\n    if (listen(server_socket, MAX_CLIENTS) == -1) {\n        perror(\"Erro ao escutar no socket\");\n#ifdef _WIN32\n        closesocket(server_socket);\n        WSACleanup();\n#endif\n        return;\n    }\n\n    printf(\"Servidor escutando na porta %d...\\n\", port);\n\n    while (1) {\n        client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);\n        if (client_socket == -1) {\n            perror(\"Erro ao aceitar conexão\");\n            continue;\n        }\n        printf(\"Conexão aceita do %s:%d (socket %d)\\n\",\n               inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), client_socket);\n\n        handle_client(client_socket);\n    }\n\n#ifdef _WIN32\n    closesocket(server_socket);\n    WSACleanup();\n#else\n    close(server_socket);\n#endif\n}\n","size_bytes":3575},"src/student/student.c":{"content":"#include \"student/student.h\"\n#include \"storage/storage.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n\n// Implementações das funções de gerenciamento de Alunos\n\n// Funções de gerenciamento de matérias para alunos - MOVIDAS PARA ADMIN\n\n// Função auxiliar para obter um ponteiro para o módulo pelo ID\nModule* get_module_by_id_ptr(int module_id) {\n    for (int i = 0; i < global_data.num_modules; ++i) {\n        if (global_data.modules[i].id == module_id) {\n            return &global_data.modules[i];\n        }\n    }\n    return NULL;\n}\n\n// Função auxiliar para obter um ponteiro para a aula pelo ID\nLesson* get_lesson_by_id_ptr(int lesson_id) {\n    for (int i = 0; i < global_data.num_lessons; ++i) {\n        if (global_data.lessons[i].id == lesson_id) {\n            return &global_data.lessons[i];\n        }\n    }\n    return NULL;\n}\n\n// Função auxiliar para obter um ponteiro para o quiz pelo ID\nQuiz* get_quiz_by_id_ptr(int quiz_id) {\n    for (int i = 0; i < global_data.num_quizzes; ++i) {\n        if (global_data.quizzes[i].id == quiz_id) {\n            return &global_data.quizzes[i];\n        }\n    }\n    return NULL;\n}\n\nvoid student_list_modules_in_subject(int student_id, int subject_id, char* data_buffer, int buffer_size) {\n    /* Inicializa buffer */\n    if (buffer_size > 0 && data_buffer) data_buffer[0] = '\\0';\n    if (!data_buffer || buffer_size <= 0) return;\n\n    /* Encontra aluno */\n    Student* student = NULL;\n    for (int i = 0; i < global_data.num_students; ++i) {\n        if (global_data.students[i].id == student_id) {\n            student = &global_data.students[i];\n            break;\n        }\n    }\n    if (!student) {\n        snprintf(data_buffer, buffer_size, \"Aluno com id %d não encontrado.\", student_id);\n        return;\n    }\n\n    /* Encontra matéria */\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; ++i) {\n        if (global_data.subjects[i].id == subject_id) {\n            subject = &global_data.subjects[i];\n            break;\n        }\n    }\n    if (!subject) {\n        snprintf(data_buffer, buffer_size, \"Matéria com id %d não encontrada.\", subject_id);\n        return;\n    }\n\n    /* Verifica matrícula do aluno na matéria */\n    int enrolled = 0;\n    for (int i = 0; i < student->num_enrolled_subjects; ++i) {\n        if (student->enrolled_subject_ids[i] == subject_id) {\n            enrolled = 1;\n            break;\n        }\n    }\n    if (!enrolled) {\n        snprintf(data_buffer, buffer_size, \"Aluno id=%d não está matriculado na matéria id=%d.\", student_id, subject_id);\n        return;\n    }\n\n    /* Verifica se há módulos na matéria */\n    if (subject->num_modules <= 0) {\n        snprintf(data_buffer, buffer_size, \"Matéria id=%d não possui módulos cadastrados.\", subject_id);\n        return;\n    }\n\n    /* Percorre módulos e formata no buffer com cuidado para não estourar */\n    int used = 0;\n    for (int i = 0; i < subject->num_modules; ++i) {\n        int mid = subject->module_ids[i];\n        Module* module = NULL;\n        for (int j = 0; j < global_data.num_modules; ++j) {\n            if (global_data.modules[j].id == mid) {\n                module = &global_data.modules[j];\n                break;\n            }\n        }\n\n        const char* mname = \"(sem nome)\";\n        int n_lessons = 0;\n        int n_quizzes = 0;\n        if (module) {\n            if (strlen(module->name) > 0) mname = module->name;\n            /* tenta usar campos convencionais; se não existirem, ficam em 0 */\n            n_lessons = module->num_lessons;\n            n_quizzes = module->num_quizzes;\n        } else {\n            /* módulo não encontrado globalmente */\n            mname = \"(módulo não encontrado)\";\n        }\n\n        int remaining = buffer_size - used;\n        if (remaining <= 1) break;\n\n        int n = snprintf(data_buffer + used, remaining, \"ID %d - %s | Aulas: %d | Questionários: %d\\n\", mid, mname, n_lessons, n_quizzes);\n        if (n < 0) break;\n\n        if (n >= remaining) {\n            const char ell[] = \"...(truncated)\";\n            size_t ell_len = strlen(ell);\n            if (buffer_size > (int)ell_len + 1) {\n                int pos = buffer_size - (int)ell_len - 1;\n                memcpy(data_buffer + pos, ell, ell_len);\n                data_buffer[buffer_size - 1] = '\\0';\n            }\n            return;\n        }\n\n        used += n;\n    }\n    /* buffer contém a lista (ou parte dela) já formatada */\n}\n\nvoid student_view_lessons_in_module(int student_id, int module_id, char* data_buffer, int buffer_size) {\n    /* Inicializa buffer */\n    if (buffer_size > 0 && data_buffer) data_buffer[0] = '\\0';\n    if (!data_buffer || buffer_size <= 0) return;\n\n    /* Encontra aluno */\n    Student* student = NULL;\n    for (int i = 0; i < global_data.num_students; ++i) {\n        if (global_data.students[i].id == student_id) {\n            student = &global_data.students[i];\n            break;\n        }\n    }\n    if (!student) {\n        snprintf(data_buffer, buffer_size, \"Aluno com id %d não encontrado.\", student_id);\n        return;\n    }\n\n    /* Encontra módulo */\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; ++i) {\n        if (global_data.modules[i].id == module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(data_buffer, buffer_size, \"Módulo com id %d não encontrado.\", module_id);\n        return;\n    }\n\n    /* Encontra matéria que contém o módulo */\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; ++i) {\n        Subject* s = &global_data.subjects[i];\n        for (int j = 0; j < s->num_modules; ++j) {\n            if (s->module_ids[j] == module_id) {\n                subject = s;\n                break;\n            }\n        }\n        if (subject) break;\n    }\n    if (!subject) {\n        snprintf(data_buffer, buffer_size, \"Matéria do módulo id=%d não encontrada.\", module_id);\n        return;\n    }\n\n    /* Verifica matrícula do aluno na matéria */\n    int enrolled = 0;\n    for (int i = 0; i < student->num_enrolled_subjects; ++i) {\n        if (student->enrolled_subject_ids[i] == subject->id) {\n            enrolled = 1;\n            break;\n        }\n    }\n    if (!enrolled) {\n        snprintf(data_buffer, buffer_size, \"Aluno id=%d não está matriculado na matéria id=%d.\", student_id, subject->id);\n        return;\n    }\n\n    /* Verifica se há aulas no módulo */\n    if (module->num_lessons <= 0) {\n        snprintf(data_buffer, buffer_size, \"Módulo id=%d não possui aulas cadastradas.\", module_id);\n        return;\n    }\n\n    /* Percorre aulas e formata no buffer com cuidado para não estourar */\n    int used = 0;\n    for (int i = 0; i < module->num_lessons; ++i) {\n        int lid = module->lesson_ids[i];\n        Lesson* lesson = NULL;\n        for (int j = 0; j < global_data.num_lessons; ++j) {\n            if (global_data.lessons[j].id == lid) {\n                lesson = &global_data.lessons[j];\n                break;\n            }\n        }\n\n        const char* title = \"(sem título)\";\n        const char* yt = \"(sem link)\";\n        if (lesson) {\n            if (strlen(lesson->title) > 0) title = lesson->title;\n            if (strlen(lesson->youtube_link) > 0) yt = lesson->youtube_link;\n        } else {\n            title = \"(aula não encontrada)\";\n            yt = \"(sem link)\";\n        }\n\n        int remaining = buffer_size - used;\n        if (remaining <= 1) break;\n\n        int n = snprintf(data_buffer + used, remaining, \"ID %d - %s | YouTube: %s\\n\", lid, title, yt);\n        if (n < 0) break;\n\n        if (n >= remaining) {\n            const char ell[] = \"...(truncated)\";\n            size_t ell_len = strlen(ell);\n            if (buffer_size > (int)ell_len + 1) {\n                int pos = buffer_size - (int)ell_len - 1;\n                memcpy(data_buffer + pos, ell, ell_len);\n                data_buffer[buffer_size - 1] = '\\0';\n            }\n            return;\n        }\n\n        used += n;\n    }\n    /* buffer contém a lista (ou parte dela) já formatada */\n}\n\nvoid student_view_quizzes_in_module(int student_id, int module_id, char* data_buffer, int buffer_size) {\n    /* Inicializa buffer */\n    if (buffer_size > 0 && data_buffer) data_buffer[0] = '\\0';\n    if (!data_buffer || buffer_size <= 0) return;\n\n    /* Encontra aluno */\n    Student* student = NULL;\n    for (int i = 0; i < global_data.num_students; ++i) {\n        if (global_data.students[i].id == student_id) {\n            student = &global_data.students[i];\n            break;\n        }\n    }\n    if (!student) {\n        snprintf(data_buffer, buffer_size, \"Aluno com id %d não encontrado.\", student_id);\n        return;\n    }\n\n    /* Encontra módulo */\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; ++i) {\n        if (global_data.modules[i].id == module_id) {\n            module = &global_data.modules[i];\n            break;\n        }\n    }\n    if (!module) {\n        snprintf(data_buffer, buffer_size, \"Módulo com id %d não encontrado.\", module_id);\n        return;\n    }\n\n    /* Encontra matéria que contém o módulo */\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; ++i) {\n        Subject* s = &global_data.subjects[i];\n        for (int j = 0; j < s->num_modules; ++j) {\n            if (s->module_ids[j] == module_id) {\n                subject = s;\n                break;\n            }\n        }\n        if (subject) break;\n    }\n    if (!subject) {\n        snprintf(data_buffer, buffer_size, \"Matéria do módulo id=%d não encontrada.\", module_id);\n        return;\n    }\n\n    /* Verifica matrícula do aluno na matéria */\n    int enrolled = 0;\n    for (int i = 0; i < student->num_enrolled_subjects; ++i) {\n        if (student->enrolled_subject_ids[i] == subject->id) {\n            enrolled = 1;\n            break;\n        }\n    }\n    if (!enrolled) {\n        snprintf(data_buffer, buffer_size, \"Aluno id=%d não está matriculado na matéria id=%d.\", student_id, subject->id);\n        return;\n    }\n\n    /* Verifica se há questionários no módulo */\n    if (module->num_quizzes <= 0) {\n        snprintf(data_buffer, buffer_size, \"Módulo id=%d não possui questionários cadastrados.\", module_id);\n        return;\n    }\n\n    /* Percorre questionários e formata no buffer com cuidado para não estourar */\n    int used = 0;\n    for (int i = 0; i < module->num_quizzes; ++i) {\n        int qid = module->quiz_ids[i];\n        Quiz* quiz = NULL;\n        for (int j = 0; j < global_data.num_quizzes; ++j) {\n            if (global_data.quizzes[j].id == qid) {\n                quiz = &global_data.quizzes[j];\n                break;\n            }\n        }\n\n        const char* qtitle = \"(sem título)\";\n        if (quiz && strlen(quiz->title) > 0) qtitle = quiz->title;\n        if (!quiz) qtitle = \"(questionário não encontrado)\";\n\n        int remaining = buffer_size - used;\n        if (remaining <= 1) break;\n\n        int n = snprintf(data_buffer + used, remaining, \"ID %d - %s\\n\", qid, qtitle);\n        if (n < 0) break;\n\n        if (n >= remaining) {\n            const char ell[] = \"...(truncated)\";\n            size_t ell_len = strlen(ell);\n            if (buffer_size > (int)ell_len + 1) {\n                int pos = buffer_size - (int)ell_len - 1;\n                memcpy(data_buffer + pos, ell, ell_len);\n                data_buffer[buffer_size - 1] = '\\0';\n            }\n            return;\n        }\n\n        used += n;\n    }\n    /* buffer contém a lista (ou parte dela) já formatada */\n}\n\nvoid student_view_grades(int student_id, char* data_buffer, int buffer_size) {\n    /* Inicializa buffer */\n    if (buffer_size > 0 && data_buffer) data_buffer[0] = '\\0';\n    if (!data_buffer || buffer_size <= 0) return;\n\n    /* Encontra aluno */\n    Student* student = NULL;\n    for (int i = 0; i < global_data.num_students; ++i) {\n        if (global_data.students[i].id == student_id) {\n            student = &global_data.students[i];\n            break;\n        }\n    }\n    if (!student) {\n        snprintf(data_buffer, buffer_size, \"Aluno com id %d não encontrado.\", student_id);\n        return;\n    }\n\n    int used = 0;\n    char temp_entry_buffer[MAX_STR_LEN * 3]; // Buffer maior para detalhes da nota individual\n    char header_buffer[MAX_STR_LEN * 2];     // Buffer para o cabeçalho\n\n    // Primeiro, verifica se há alguma nota para o aluno\n    int found_grades = 0;\n    for (int i = 0; i < global_data.num_grades; ++i) {\n        if (global_data.grades[i].student_id == student_id) {\n            found_grades = 1;\n            break;\n        }\n    }\n\n    if (!found_grades) {\n        snprintf(data_buffer, buffer_size, \"Nenhuma nota registrada para o aluno id=%d.\\n\", student_id);\n        return;\n    }\n\n    // Se encontrou notas, formata o cabeçalho primeiro no data_buffer\n    int n_header = snprintf(header_buffer, sizeof(header_buffer), \"\\n--- NOTAS DO ALUNO %d (%s) ---\\n\", student->id, student->name);\n    if (n_header < 0 || (size_t)n_header >= sizeof(header_buffer)) {\n        snprintf(data_buffer, buffer_size, \"Erro ao formatar cabeçalho de notas.\");\n        return;\n    }\n    // Copia o cabeçalho para o início do data_buffer\n    strncpy(data_buffer, header_buffer, buffer_size);\n    data_buffer[buffer_size - 1] = '\\0'; // Garante terminação nula\n    used += n_header;\n\n    /* Percorre notas procurando as do aluno e as adiciona após o cabeçalho */\n    for (int i = 0; i < global_data.num_grades; ++i) {\n        Grade* g = &global_data.grades[i];\n        if (g->student_id != student_id) continue;\n\n        /* encontra nome da matéria */\n        const char* subject_name = \"(sem nome)\";\n        for (int s = 0; s < global_data.num_subjects; ++s) {\n            if (global_data.subjects[s].id == g->subject_id) {\n                if (strlen(global_data.subjects[s].name) > 0) subject_name = global_data.subjects[s].name;\n                break;\n            }\n        }\n\n        /* prepara campos da nota */\n        double value = g->score;\n        /* descrição */\n        const char* desc = \"(sem descrição)\";\n        if (strlen(g->description) > 0) desc = g->description;\n\n        int remaining_for_entry = sizeof(temp_entry_buffer);\n        int n_entry = snprintf(temp_entry_buffer, remaining_for_entry, \"Matéria: %s (id=%d) | Nota: %.2f | %s\\n\",\n                                 subject_name, g->subject_id, value, desc);\n        \n        if (n_entry < 0 || (size_t)n_entry >= remaining_for_entry) {\n            continue; // Erro ou buffer temporário muito pequeno para esta entrada, pula para a próxima\n        }\n\n        int remaining_in_data_buffer = buffer_size - used;\n        if (remaining_in_data_buffer <= 1) { // Deixa espaço para o terminador nulo\n            const char ell[] = \"... (lista truncada)\\n\";\n            size_t ell_len = strlen(ell);\n            if (buffer_size > used + ell_len + 1) {\n                strncat(data_buffer + used, ell, remaining_in_data_buffer); // Usar strncat para segurança\n                used += ell_len;\n            }\n            break; // Buffer principal cheio\n        }\n        \n        // Tenta concatenar a entrada formatada no buffer principal\n        // Usar snprintf para controlar o tamanho máximo a ser escrito\n        int n_concat = snprintf(data_buffer + used, remaining_in_data_buffer, \"%s\", temp_entry_buffer);\n        if (n_concat < 0 || n_concat >= remaining_in_data_buffer) {\n            // Não foi possível adicionar a entrada completa, truncar ou parar\n            const char ell[] = \"... (lista truncada)\\n\";\n            size_t ell_len = strlen(ell);\n            if (buffer_size > used + ell_len + 1) {\n                strncat(data_buffer + used, ell, remaining_in_data_buffer); // Usar strncat para segurança\n                used += ell_len;\n            }\n            break; // Buffer principal cheio\n        }\n        used += n_concat;\n    }\n}\n\nint student_get_quiz_questions(int student_id, int quiz_id, char* data_buffer, int buffer_size, char* response_message, int max_response_len) {\n    if (buffer_size <= 0 || !data_buffer) {\n        if (max_response_len > 0 && response_message) snprintf(response_message, max_response_len, \"Buffer de dados inválido.\");\n        return -1;\n    }\n    data_buffer[0] = '\\0'; // Clear data buffer\n\n    if (max_response_len <= 0 || !response_message) return -1;\n    response_message[0] = '\\0'; // Clear response message buffer\n\n    // 1. Find Student\n    Student* student = NULL;\n    for (int i = 0; i < global_data.num_students; ++i) {\n        if (global_data.students[i].id == student_id) {\n            student = &global_data.students[i];\n            break;\n        }\n    }\n    if (!student) {\n        snprintf(response_message, max_response_len, \"Aluno com ID %d não encontrado.\", student_id);\n        return -1;\n    }\n\n    // 2. Find Quiz\n    Quiz* quiz = NULL;\n    for (int i = 0; i < global_data.num_quizzes; ++i) {\n        if (global_data.quizzes[i].id == quiz_id) {\n            quiz = &global_data.quizzes[i];\n            break;\n        }\n    }\n    if (!quiz) {\n        snprintf(response_message, max_response_len, \"Questionário com ID %d não encontrado.\", quiz_id);\n        return -1;\n    }\n\n    // 3. Find Module containing the Quiz\n    Module* module = NULL;\n    for (int i = 0; i < global_data.num_modules; ++i) {\n        Module* m = &global_data.modules[i];\n        for (int j = 0; j < m->num_quizzes; ++j) {\n            if (m->quiz_ids[j] == quiz_id) {\n                module = m;\n                break;\n            }\n        }\n        if (module) break;\n    }\n    if (!module) {\n        snprintf(response_message, max_response_len, \"Módulo do questionário %d não encontrado.\", quiz_id);\n        return -1;\n    }\n\n    // 4. Find Subject containing the Module\n    Subject* subject = NULL;\n    for (int i = 0; i < global_data.num_subjects; ++i) {\n        Subject* s = &global_data.subjects[i];\n        for (int j = 0; j < s->num_modules; ++j) {\n            if (s->module_ids[j] == module->id) {\n                subject = s;\n                break;\n            }\n        }\n        if (subject) break;\n    }\n    if (!subject) {\n        snprintf(response_message, max_response_len, \"Matéria do módulo %d não encontrada.\", module->id);\n        return -1;\n    }\n\n    // 5. Verify if the student is enrolled in the subject\n    int enrolled = 0;\n    for (int i = 0; i < student->num_enrolled_subjects; ++i) {\n        if (student->enrolled_subject_ids[i] == subject->id) {\n            enrolled = 1;\n            break;\n        }\n    }\n    if (!enrolled) {\n        snprintf(response_message, max_response_len, \"Aluno %d não está matriculado na matéria %d do questionário %d.\", student_id, subject->id, quiz_id);\n        return -1;\n    }\n\n    // 6. Format questions into data_buffer\n    if (quiz->num_questions <= 0) {\n        snprintf(response_message, max_response_len, \"Questionário %d não possui perguntas.\", quiz_id);\n        return -1;\n    }\n\n    int used_buffer_size = 0;\n    int remaining_buffer_size = buffer_size;\n    int n_written;\n\n    // First line: number of questions\n    n_written = snprintf(data_buffer + used_buffer_size, remaining_buffer_size, \"%d\\n\", quiz->num_questions);\n    if (n_written < 0 || n_written >= remaining_buffer_size) {\n        snprintf(response_message, max_response_len, \"Buffer insuficiente para perguntas do questionário.\");\n        return -1;\n    }\n    used_buffer_size += n_written;\n    remaining_buffer_size -= n_written;\n\n    for (int i = 0; i < quiz->num_questions; ++i) {\n        Question* q = &quiz->questions[i];\n        if (remaining_buffer_size <= 1) { // Leave space for null terminator\n            snprintf(response_message, max_response_len, \"Buffer insuficiente para todas as perguntas do questionário.\");\n            return -1;\n        }\n\n        // Novo formato: ID|LEN_TEXTO|TEXTO|LEN_OPCAO1|OPCAO1|LEN_OPCAO2|OPCAO2|LEN_OPCAO3|OPCAO3|LEN_OPCAO4|OPCAO4\\n\n        // Calculando comprimentos para evitar problemas com caracteres especiais e quebras de linha\n        int len_text = strlen(q->text);\n        int len_opt1 = strlen(q->options[0]);\n        int len_opt2 = strlen(q->options[1]);\n        int len_opt3 = strlen(q->options[2]);\n        int len_opt4 = strlen(q->options[3]);\n\n        n_written = snprintf(data_buffer + used_buffer_size, remaining_buffer_size,\n                             \"%d|%d|%s|%d|%s|%d|%s|%d|%s|%d|%s\\n\",\n                             q->id, len_text, q->text,\n                             len_opt1, q->options[0],\n                             len_opt2, q->options[1],\n                             len_opt3, q->options[2],\n                             len_opt4, q->options[3]);\n        \n        if (n_written < 0 || n_written >= remaining_buffer_size) {\n            snprintf(response_message, max_response_len, \"Buffer insuficiente para formatar pergunta %d.\", q->id);\n            return -1;\n        }\n        used_buffer_size += n_written;\n        remaining_buffer_size -= n_written;\n    }\n\n    snprintf(response_message, max_response_len, \"Perguntas do questionário %d obtidas com sucesso.\", quiz_id);\n    return 0;\n}\n\nint student_submit_quiz_answers(int student_id, int quiz_id, const char* answers_str, char* response_message, int max_response_len) {\n    if (max_response_len <= 0 || !response_message) return -1;\n    response_message[0] = '\\0'; // Clear response message buffer\n\n    // 1. Find Student\n    Student* student = NULL;\n    for (int i = 0; i < global_data.num_students; ++i) {\n        if (global_data.students[i].id == student_id) {\n            student = &global_data.students[i];\n            break;\n        }\n    }\n    if (!student) {\n        snprintf(response_message, max_response_len, \"Aluno com ID %d não encontrado.\", student_id);\n        return -1;\n    }\n\n    // 2. Find Quiz\n    Quiz* quiz = NULL;\n    for (int i = 0; i < global_data.num_quizzes; ++i) {\n        if (global_data.quizzes[i].id == quiz_id) {\n            quiz = &global_data.quizzes[i];\n            break;\n        }\n    }\n    if (!quiz) {\n        snprintf(response_message, max_response_len, \"Questionário com ID %d não encontrado.\", quiz_id);\n        return -1;\n    }\n\n    if (quiz->num_questions == 0) {\n        snprintf(response_message, max_response_len, \"Questionário %d não possui perguntas para serem respondidas.\", quiz_id);\n        return -1;\n    }\n\n    // Parse answers_str: \"Q_ID:Answer_Option,Q_ID:Answer_Option,...\"\n    char temp_answers_str[MAX_DATA_LEN];\n    strncpy(temp_answers_str, answers_str, MAX_DATA_LEN - 1);\n    temp_answers_str[MAX_DATA_LEN - 1] = '\\0';\n\n    int correct_answers_count = 0;\n    int total_questions_answered = 0;\n\n    char* answer_pair_token = strtok(temp_answers_str, \",\");\n    while (answer_pair_token != NULL) {\n        int q_id, student_answer;\n        if (sscanf(answer_pair_token, \"%d:%d\", &q_id, &student_answer) == 2) {\n            total_questions_answered++;\n            // Find the question in the quiz\n            Question* current_question = NULL;\n            for (int i = 0; i < quiz->num_questions; ++i) {\n                if (quiz->questions[i].id == q_id) {\n                    current_question = &quiz->questions[i];\n                    break;\n                }\n            }\n\n            if (current_question) {\n                if (student_answer == current_question->correct_option) {\n                    correct_answers_count++;\n                }\n            }\n        }\n        answer_pair_token = strtok(NULL, \",\");\n    }\n\n    if (total_questions_answered == 0) {\n        snprintf(response_message, max_response_len, \"Nenhuma resposta válida foi fornecida para o questionário %d.\", quiz_id);\n        return -1;\n    }\n\n    // Calculate score (simple percentage for now)\n    float score = (float)correct_answers_count / quiz->num_questions * 100.0f;\n\n    // Store Quiz Result (simplified - just adds to a global array for now)\n    if (global_data.num_quiz_results < MAX_QUIZ_RESULTS) {\n        QuizResult new_result;\n        new_result.id = generate_next_id(); // Assumes a function to generate unique IDs\n        new_result.student_id = student_id;\n        new_result.quiz_id = quiz_id;\n        new_result.score = score;\n        time(&new_result.timestamp); // Set current timestamp\n\n        global_data.quiz_results[global_data.num_quiz_results++] = new_result;\n        if (save_data(\"system_data.dat\") != 0) {\n            snprintf(response_message, max_response_len, \"Falha ao salvar o resultado do questionário.\");\n            return -1;\n        }\n    } else {\n        snprintf(response_message, max_response_len, \"Limite de resultados de questionário atingido. Resultado não salvo.\");\n        return -1;\n    }\n\n    snprintf(response_message, max_response_len, \"Questionário \\\"%s\\\" (ID: %d) finalizado. Você acertou %d de %d perguntas. Sua nota: %.2f.\",\n             quiz->title, quiz_id, correct_answers_count, quiz->num_questions, score);\n    return 0;\n}\n\nvoid student_view_absences(int student_id, char* data_buffer, int buffer_size) {\n    if (buffer_size > 0 && data_buffer) data_buffer[0] = '\\0';\n    if (!data_buffer || buffer_size <= 0) return;\n\n    Student* student = NULL;\n    for (int i = 0; i < global_data.num_students; ++i) {\n        if (global_data.students[i].id == student_id) {\n            student = &global_data.students[i];\n            break;\n        }\n    }\n    if (!student) {\n        snprintf(data_buffer, buffer_size, \"Erro: Aluno com ID %d não encontrado.\", student_id);\n        return;\n    }\n\n    int used = 0;\n    char temp_entry_buffer[MAX_STR_LEN * 3]; // Buffer maior para detalhes da falta\n    char header_buffer[MAX_STR_LEN * 2];     // Buffer para o cabeçalho\n\n    // Primeiro, verifica se há alguma falta para o aluno\n    int found_absences = 0;\n    for (int i = 0; i < global_data.num_absences; ++i) {\n        if (global_data.absences[i].student_id == student_id) {\n            found_absences = 1;\n            break;\n        }\n    }\n\n    if (!found_absences) {\n        snprintf(data_buffer, buffer_size, \"Nenhuma falta registrada para o aluno com ID %d.\\n\", student_id);\n        return;\n    }\n\n    // Se encontrou faltas, formata o cabeçalho primeiro no data_buffer\n    int n_header = snprintf(header_buffer, sizeof(header_buffer), \"\\n--- FALTAS DO ALUNO %d (%s) ---\\n\", student->id, student->name);\n    if (n_header < 0 || (size_t)n_header >= sizeof(header_buffer)) {\n        snprintf(data_buffer, buffer_size, \"Erro ao formatar cabeçalho de faltas.\");\n        return;\n    }\n    // Copia o cabeçalho para o início do data_buffer\n    strncpy(data_buffer, header_buffer, buffer_size);\n    data_buffer[buffer_size - 1] = '\\0'; // Garante terminação nula\n    used += n_header;\n\n    for (int i = 0; i < global_data.num_absences; ++i) {\n        Absence* a = &global_data.absences[i];\n        if (a->student_id != student_id) continue;\n\n        const char* subject_name = \"(sem nome)\";\n        Subject* subject = NULL;\n        for (int s = 0; s < global_data.num_subjects; ++s) {\n            if (global_data.subjects[s].id == a->subject_id) {\n                subject = &global_data.subjects[s];\n                if (strlen(subject->name) > 0) subject_name = subject->name;\n                break;\n            }\n        }\n\n        const char* justification = \"Nenhuma\";\n        if (strlen(a->justification) > 0) {\n            justification = a->justification;\n        }\n\n        int remaining_for_entry = sizeof(temp_entry_buffer);\n        int n_entry = snprintf(temp_entry_buffer, remaining_for_entry, \"Matéria: %s (ID: %d) | Data: %s | Justificativa: %s\\n\",\n                                 subject_name, a->subject_id, a->date, justification);\n        if (n_entry < 0 || (size_t)n_entry >= remaining_for_entry) {\n            continue;\n        }\n\n        int remaining_in_data_buffer = buffer_size - used;\n        if (remaining_in_data_buffer <= 1) {\n            const char ell[] = \"... (lista truncada)\\n\";\n            size_t ell_len = strlen(ell);\n            if (buffer_size > used + ell_len + 1) {\n                strncat(data_buffer + used, ell, remaining_in_data_buffer); // Usar strncat para segurança\n                used += ell_len;\n            }\n            break;\n        }\n\n        int n_concat = snprintf(data_buffer + used, remaining_in_data_buffer, \"%s\", temp_entry_buffer);\n        if (n_concat < 0 || n_concat >= remaining_in_data_buffer) {\n            const char ell[] = \"... (lista truncada)\\n\";\n            size_t ell_len = strlen(ell);\n            if (buffer_size > used + ell_len + 1) {\n                strncat(data_buffer + used, ell, remaining_in_data_buffer); // Usar strncat para segurança\n                used += ell_len;\n            }\n            break;\n        }\n        used += n_concat;\n    }\n}\n","size_bytes":28796}},"version":2}